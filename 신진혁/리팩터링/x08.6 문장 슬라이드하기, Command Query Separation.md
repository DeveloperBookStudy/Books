함수를 추출하기 전에 문장을 위, 아래로 슬라이드하여 관련 있는 코드들끼리 모아두어야 한다.

그래서 코드를 작성할 땐 객체를 선언하는 곳과 사용하는 곳을 가깝게 관리하는 것이 좋다.

만약 코드를 슬라이드하게 된다면, 해당 함수 내부에 다른 코드들이 사이드 이펙트를 발생시키지 않는다는 조건이 필요하다.

다른 코드들이 사이드 이펙트를 발생시키지 않는다는 확신이 없다면 함부로 코드를 슬라이드 할 수 없다.

확신이 들지 않는다면 모든 코드들을 일일이 분석해야 한다.

사이드 이펙트를 발생시키는 코드를 슬라이드하면?

```kotlin
/* ------------------------------
   예시 ① : 순수(pure) 함수 – 사이드 이펙트 없음
   ------------------------------ */
fun square(x: Int): Int = x * x           // 입력만으로 결과 결정, 외부 상태 변화 X

/* ------------------------------
   예시 ② : 사이드 이펙트를 일으키는 함수
   ------------------------------ */
var globalCounter = 0                     // 전역 상태

fun incrementCounter() {                  // ❶ 전역 변수 변경 → 사이드 이펙트
    globalCounter++
}

fun log(message: String) {                // ❷ 콘솔 출력 → 외부 세계(표준 출력) 변경
    println(message)
}

/* ------------------------------
   문장(Statement) 슬라이드 전‧후에 의미가 달라지는지 확인
   ------------------------------ */
fun main() {
    /* (A) 원래 코드 순서 */
    val before = square(globalCounter)    //  결과 0  (globalCounter == 0)
    incrementCounter()                    //  globalCounter == 1
    log("before = $before, counter = $globalCounter")

    /* (B) incrementCounter 문장을 위쪽으로 ‘슬라이드’ 했다면 */
    incrementCounter()                    //  globalCounter == 2   ← 이미 증가
    val after = square(globalCounter)     //  결과 4  (2 * 2)      ← 값 달라짐!
    log("after  = $after, counter = $globalCounter")
}
```

- 사이드 이펙트를 가진 함수를 움직이면 로직이 달라진다.
- 사이드 이펙트를 가진 함수를 쓰면 안된다는 것이 아니다! 그냥 함부로 슬라이드 할 수 없을 뿐이다.

그럼 사이드 이펙트를 발생시키는 함수와 그렇지 않은 함수를 잘 구분하자!

### Command Query Separation

1. Query
    
    • **값을 돌려준다(return)**
    
    • **시스템의 관찰 가능한 상태를 바꾸지 않는다** (부작용 X)
    
2. Command(Modifier / Mutator)
    
    • **상태를 바꾼다**
    
    • **아무것도 돌려주지 않는다** (Kotlin: `Unit`)
    

이 규칙을 지키면
• **“읽기 전용” 메서드**는 어디서·몇 번 호출해도 프로그램이 흔들리지 않고

• **“쓰기” 메서드**는 신중하게 위치·순서를 고민하게 된다.

(1) 규칙을 잘 지킨 코드

```kotlin
class BankAccount(initial: Int = 0) {

    /* 상태 */
    private var balance: Int = initial

    **/** ── Command ── : 상태 변경,** 반환값 없음 */
    fun deposit(amount: Int) {               // **Unit 반환**
        require(amount > 0)
        balance += amount
    }

    **/** ── Query ── : 상태 미변경**, 값 반환 */
    fun balance(): Int = balance             // Int 반환, **side-effect X**
}

```

- deposit 은 돈을 넣을 뿐 값을 돌려주지 않는다.
- balance() 는 현재 값만 읽고 내부를 건드리지 않는다.

(2) 규칙을 깨는 코드(❌)

```kotlin
**/** 돈을 인출하면서 동시에 새 잔액을 돌려준다 */**
fun withdraw(amount: Int): Int {
    require(amount > 0)
    balance -= amount         // 상태 변경
    return balance            // 값 반환  ← Query + Command 혼합
}

```

→ 호출 순서가 바뀌면 결과가 달라진다.

```kotlin
println(acc.withdraw(10))   // 90
println(acc.withdraw(10))   // 80
```

→ 테스트·리팩터링 난이도 상승.

(3) 개선

```kotlin
fun withdraw(amount: Int) {          // Command
    /* … */
}
fun balance(): Int = balance         // Query

```

스택의 pop( ) 는 왜 예외로 용납?

```kotlin
class Stack<E> {
    private val items = arrayListOf<E>()

    fun push(e: E) { items += e }            // Command

    fun peek(): E? = items.lastOrNull()      // Query

    fun pop(): E? =                          // Query + Command (예외)
        items.removeLastOrNull()
}

```

스택은 “꺼내면 동시에 제거”가 자연스러운 도메인 규칙이라

편익이 비용(CQS 위배)보다 크다고 판단해 예외로 둡니다.

### 결론

1. 메서드를 만들 때 먼저 “값을 돌려줄까? 상태를 바꿀까?”를 나눠라.
2. 상태를 바꿔야 한다면 **반환형을 `Unit`으로**(커맨드임을 명확히).
3. 조회 용도로만 쓰는 메서드는 **side-effect 가 없는지** 점검.
4. 예외(스택 pop, Iterator.next 등)를 만들 땐
– 정말 편의성이 필요한지
– 주석·테스트로 동작을 충분히 명시했는지 확인한다.
