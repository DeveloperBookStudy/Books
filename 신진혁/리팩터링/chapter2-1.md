## 2.1 리팩터링 정의

- 다순히 코드를 정리하는 작업이 아닌 **특정한 방식에 따라 정리하는 것만이 리팩터링이다.**
- 재구성 : 코드베이스를 정리하거나 구조를 바꾸는 모든 작업
    
    → **리팩터링은 재구성** 중 특수한 한 형태
    
- 리팩터링 하기 **전과 후의 코드가 똑같이 동작해야 한다.**
    - **성능이 조금 달라질 순 있다.**
    - 버그 또한 그대로여야 한다.
- 리팩터링의 **목적**은 **코드를 이해하고 수정하기 쉽게 만드는 것**이다.
    
    → 성능이 좋아질 수도 나빠질 수도 있다.
    

## 2.2 두개의 모자

- 개발의 목적을 **기능 추가**와 **리팩터링**은 명확히 구분해서 진행하자
- **기능 추가**할 땐 기존 코드를 건드리지 않고 **새 기능만 추가**해야 한다.
    - 테스트 코드를 통해 진척도를 측정한다.
- **리팩터링**할 땐 기능 추가는 절대 하지 않고 **코드 재구성만** 해야 한다.
    - 새로운 테스트 코드도 작성하지 않는다.
- 개발을 진행하면서 **두 목적을 자주 바꿔가면서 진행**한다.
    - 단, 각각의 작업을 **확실히 구분**해야 한다.

## 2.3 리팩터링하는 이유

### 소프트웨어 설계가 좋아 진다.

- 아키텍처를 충분히 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 내부 설계(아키텍처)가 썩기 쉽다.
    
    → **규칙적인 리팩터링**은 코드의 구조를 지탱해줄 것이다.
    
- 코드량이 줄면 수정하는 데 드는 노력도 줄어 든다.
    
    → **중복 코드를 제거**하면 모드 코드가 언제나 **고유한 일을 수행함을 보장**할 수 있다.
    

### 소프트웨어를 이해하기 쉬워진다.

- 다른 프로그래머와 나 자신이 내 코드를 이해하기 쉽게 작성해야 한다.
- 리팩터링은 코드의 목적이 더 잘 드러나게, 내 의도를 더 명확하게 전달하도록 개선시켜 준다.

### 버그를 쉽게 찾을 수 있다.

- 리팩터링하면 코드가 하는 일을 깊이 파악하게 되고, 버그를 발견하기 쉬워진다.

### 프로그래밍 속도를 높일 수 있다.

- 내부 설계가 잘 된 소프트웨어는 **새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다.**
    - **모듈화**가 잘 되어 있으면 전체 코드 베이스 중 작은 일부만 이해하면 된다.
- 내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다.
- 처음부터 좋은 설계를 마련하기는 어렵다. **지속적인 리팩터링**이 있어야 **빠른 개발**이 가능하다.

## 2.4 언제 리팩터링해야 할까?

### 준비를 위한 리팩터링 : 기능을 쉽게 추가하게 만들기

- 리팩터링은 **새로운 기능을 추가하기 직전**이 가장 좋다.
- 리팩터링은 **버그를 수정하기 직전**에도 좋다.

### 이해를 위한 리팩터링 : 코드를 이해하기 쉽게 만들기

- 코드를 수정하려면 먼저 그 **코드가 하는 일을 파악**해야 한다.
- 코드를 파악할 때마다 그 코드의 **의도가 더 명확하게 드러나도록** 리팩터링할 여지는 없는지 찾아본다.
    - **조건부 로직의 구조**가 이상한지 않은지
    - **함수 이름**이 잘못 설정되어 있지 않은지
- 세부 코드 이해를 위해 리팩터링을 해야한다.
    - 어떤 역할을 하는지 이해된 변수는 **적절한 이름**으로 바꿔주고, **긴 함수를 잘게 나누어** 준다.

### 쓰레기 줍기 리팩터링

- 간단히 수정할 수 있는 것은 즉시 고치고, 시간이 좀 걸리는 일은 짧은 메모만 남긴 다음, 하던 일을 끝내고 처리한다.

### 계획된 리팩터링과 수시로 하는 리팩터링

- 리팩터링 기술을 적용할 기준을 만들어 그 기준을 통과하면 추가적인 작업을 하고, 통과하지 못하면 리팩터링을 하는 방식으로 진행하는 것이 좋다.
- 계획된 리팩터링은 최소한으로 줄이고, 기회가 될 때마다 진행한다.
