캡슐화는 모듈들이 시스템의 다른 부분에 대해 알아야 할 내용을 줄여준다. 

→ 무언가를 변경해야 할 때 함께 고려해야 할 모 듈 수가 적어져서 코드를 변경하기 쉬워진다.

<aside>
💡

클라이언트가 서버 객체의 필드가 가리키는 객체(위임 객체)를 알고 있으면 해당 객체의 인터페이스가 변경될 경우 모든 클라이언트 코드도 수정되어야 한다.

</aside>

이게 무슨 말이냐… 대충 예를 들면

```kotlin
data class Person(
    val name: String,
    val department: Department     
) {
    data class Department(   
        val chargeCode: Int,
        val manager: String
    )
}
```

이런 클래스가 있을 때, 이 Person 객체의 manaer를 알려면 클라이언트에선 

```kotlin
fun main() {
    val person = Person(
        name = "김덕배",
        department = Person.Department(
            chargeCode = 104,
            manager = "매니저"
        )
    )

		printManagerUpper(person)
    sendMail(person)
}

fun printManagerUpper(person: Person) =
    println(**person.department.manager**.uppercase())

fun sendMail(person: Person) {
    println("메일을 보냅니다 → ${**person.department.manager**}")
}
```

이렇게 department 를 통해 manager를 직접 호출해야 한다.

이렇게 될 경우, 만약 manager의 필드명이 바뀐다면?

```kotlin
data class Person(
    val name: String,
    val department: Department     
) {
    data class Department(   
        val chargeCode: Int,
        val **supervisor**: String
    )
}
```

그럼 이것을 사용하는 클라이언트 코드도 변경되어야 한다.

```kotlin
fun printManagerUpper(person: Person) =
    println(**person.department.supervisor**.uppercase())

fun sendMail(person: Person) {
    println("메일을 보냅니다 → ${**person.department.supervisor**}")
}
```

혹은 만약 manager의 타입이 변경된다면?

```kotlin
data class Person(
    val name: String,
    val department: Department            
) {
    data class Department(
        val chargeCode: Int,
        **val manager: List<String>**     
    )
}
```

혹은 만약 manager라는 프로퍼티가 함수로 변경된다면?

```kotlin
data class Person(
    val name: String,
    val department: Department
) {
    data class Department(
        val chargeCode: Int,
    ) {
        **fun manager(): String = "매니저"**
    }
}
```

**객체의 위임 객체(Department)는 숨겨서 사용하자**

```kotlin
data class Person(
    val name: String,
    private val department: Department      // ← 숨김
) {
    data class Department(
        val chargeCode: Int,
        val manager: String
    )

		// 중개자, 객체 혹은 메서드
    val manager get() = department.manager
}

fun main() {
    val person = Person(
        name = "김덕배",
        department = Person.Department(
            chargeCode = 104,
            manager = "매니저"
        )
    )

    **val 김덕배manager = person.manager**
}
```

이렇게 숨기면 Department에 변경사항이 생겨도 클라이언트 쪽에서 대응할 필요가 없다!

그럼 Department에 변경사항이 자주 생긴다거나, 확정되지 않았다고 한다면?

```kotlin
data class Person(
    val name: String,
    private val department: Department
) {
    fun manager(): String =
        when (department) {
            is DepartmentV1 -> department.manager
            is DepartmentV2 -> department.supervisor
            is DepartmentV3 -> department.manager()
        }

    sealed interface Department

    data class DepartmentV1(
        val chargeCode: Int,
        val manager: String
    ) : Department

    data class DepartmentV2(
        val chargeCode: Int,
        val supervisor: String
    ) : Department

    data class DepartmentV3(
        val chargeCode: Int,
    ) : Department {
        fun manager(): String = "매니저"
    }

    companion object {
        // V1
        fun department(
            name: String,
            chargeCode: Int,
            manager: String,
        ): Person = Person(name, DepartmentV1(chargeCode, manager))

//        // V2
//        fun department(
//            name: String,
//            chargeCode: Int,
//            supervisor: String,
//        ): Person = Person(name, DepartmentV2(chargeCode, supervisor))
//
//        // V3
//        fun department(
//            name: String,
//            chargeCode: Int,
//        ): Person = Person(name, DepartmentV3(chargeCode))
    }
}
```

이렇게 내부에 sealed interface로 확정되지 않은 클래스를 만들고, 버전 별로 클래스를 생성한 뒤 static 메서드로 생성할 수 있게 만들면 서버의 변경이 생겨도 

클라이언트 쪽에서는 Department 객체 생성 static 메서드 하나만 바꾸면 된다. 

<aside>
💡

디미터의 법칙은 “객체의 내부 구조(또는 내부의 내부)까지 들여다보지 말고, 그 객체에게 원하는 결과를 직접 요청하라”는 설계 지침이다. 이를 지키면 모듈 간 결합이 느슨해지고 변경에 강한 코드가 된다.

</aside>

그런데 만약 Department에 프로퍼티가 계속 추가된다?

```kotlin
data class Person(
    val name: String,
    private val department: Department      // ← 숨김
) {
    data class Department(
        val chargeCode: Int,
        val manager: String,
        val address: String,
    )

    val departmentChargeCode get() = department.chargeCode
    val departmentAddress get() = department.address
    val manager get() = department.manager
}
...
data class Person(
    val name: String,
    private val department: Department      // ← 숨김
) {
    data class Department(
        val chargeCode: Int,
        val manager: String,
        val address: String,
        val newProperty: String,
    )

    val departmentNewProperty get() = department.newProperty
    val departmentChargeCode get() = department.chargeCode
    val departmentAddress get() = department.address
    val manager get() = department.manager
}
```

이렇게 계속 중개 메서드 혹은 객체가 늘어난다… 이런 경우라면?

그냥 중개자를 제거하자….

```kotlin
data class Person(
    val name: String,
    val department: Department
) {
    data class Department(
        val chargeCode: Int,
        val manager: String,
        val address: String,
        val newProperty: String,
    )
}
```

### 적절히 래핑하고, 적절히 위임하자
