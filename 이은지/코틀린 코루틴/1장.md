# 1장 코틀린 코루틴을 배워야 하는 이유

## 코루틴을 사용한 예제와 잘 알려진 기존의 접근 방식을 사용한 예제 비교

### 안드로이드(그리고 다른 프론트엔드 플랫폼)에서의 코루틴 사용 

1. API로부터 뉴스를 가지고 와서 정렬한 다음, 스크린에 띄우는 로직
    ``` kotlin
    fun onCreate() {
      val news = getNewsFromApi() //1. 하나 또는 다양한 소스로부터 데이터를 얻어온다.
      val sortedNews = news.sortedByDescending { it.publishedAt } //2. 데이터를 처리한다.
      view.showNews(shortedNesw) //3. 가공된 데이터로 무엇인가를 한다.
    }
    ```
    - 안드로이드에서는 하나의 앱에서 뷰를 다루는 스레드가 단 하나만 존재하는데, 이 스레드는 앱에서 가장 중요한 스레드라 블로킹되면 안 된다. 따라서 이런 방법으로 구현할 수 없다.
    - onCreate 함수가 메인 스레드에서 실행된다면 getNewsFromApi 함수가 스레드를 블로킹할 것이고, 애플리케이션에 앱 크래시가 발생할 것이다.
    - getNewsFromApi 함수를 다른 스레드에서 실행하더라도 showNews를 호출할 때 정보가 없으므로 메인 스레드에서도 마찬가지로 크래시가 발생한다.

2. 스레드 전환 방식 =>  블로킹이 가능한 스레드를 먼저 사용하고 이후에 메인 스레드로 전환한다.
    ``` kotlin
    fun onCreate() {
      thread {
        val news = getNewsFromApi()
        val sortedNews = news.sortedByDescending { it.publishedAt }
        funOnUiThread {
          view.showNews(sortedNews)
        }
      }
    }
    ```
    - 스레드가 실행되었을 떄 멈출 수 있는 방법이 없어 메모리 누수로 이어질 수 있다
    - 스레드를 많이 생성하면 비용이 많이 든다.
    - 스레드를 자주 전환하면 복잡도를 증가시키며 관리하기 어렵다
    - 코드가 쓸데없이 길어지고 이해하기 어렵다.
    - 예를 들어, 뷰를 열었다가 재빨리 닫는 경우
      - 뷰가 열려 있는 동안, 데이터를 가져와 처리하는 스레드가 다수 생성된다
      - 생성된 스레드를 제거하지 않으면, 스레드는 주어진 작업을 계속 수행한 후 더 이상 존재하지 않는 뷰를 수정하려고 시도할 것이다
      - 이것은 디바이스에 불필요한 작업이며, 백그라운드에서 예외를 유발하거나 예상하기 어려운 결과가 발생할 수 있다

3. 콜백 사용 => 함수를 논블로킹으로 만들고, 함수의 작업이 끝났을 때 호출될 콜백 함수를 넘겨준다.
    ``` kotlin
    fun onCreate() {
      getNewsFromApi { news ->
        val sortedNews = news.sortedByDescending { it.publishedAt }
        view.showNews(sortedNews)
      }
    }
    ```
    - 콜백을 이용해 구현한 방식 또한 중간에 작업을 취소할 수 없다.
    - 취소할 수 있는 콜백 함수를 만들 수도 있지만 쉽지 않다.
      - 콜백 함수 각각에 대해 취소할 수 있도록 구현해야 할 뿐 아니라, 취소하기 위해선 모든 객체를 분리해서 모아야 한다.
    - 예를 들어, 세 군데서 데이터를 얻어오는 경우
      ``` kotlin
      fun showNews() {
        getConfigFromApi { config -> 
          getNewsFromApi(config) { news -> 
            getUserFromApi { user ->
              view.showNews(user, news)
            }
          } 
        }
      }
      ```
      - 뉴스를 얻어오는 작업과 사용자 데이터를 얻어오는 작업은 병렬로 처리할 수 있지만, 현재의 콜백 구조로는 두 작업을 동시에 처리할 수 없다.
      - 취소할 수 있도록 구현하려면 많은 노력이 필요하다.
      - 들여쓰기가 많아질수록 코드는 읽기 어려워진다(콜백 지옥)
      - 콜백을 사용하면 작업의 순서를 다루기 힘들어진다.
        ``` kotlin
        fun onCreate() {
          showProgressBar()
          showNews()
          hideProgressBar() //잘못된 방식 - 프로그레스 바는 뉴스를 보여 주는 작업을 시작하고 곧바로 사라진다.
        }
        ```
        ``` kotlin
        fun onCreate() {
          showProgressBar()
          showNews {
            hideProgressBar()
          } //프로그레스 바가 제대로 작동하게 하려면 showNews 에도 콜백 함수를 만들어야 한다.
        }
        ```

4. RxJava와 리액티브 스트림 => 데이터 스트림 내에서 일어나는 모든 연산을 시작, 처리, 관찰할 수 있다. 또한 리액티브 스트림은 스레드 전환과 동시성 처리를 지원하기 때문에 애플리케이션 내의 연산을 병렬 처리하는 데 사용된다.
    ``` kotlin
    fun onCreate() {
      disposables += getNewsFromApi()
        .subscribeOn(Schedulers.io())
        .observeOn(AndroidSchedulers.mainThread())
        .map { news -> 
          news.sortedByDescending { it.publishedAt }
        }
        .subscribe { sortedNews -> 
          view.showNews(sortedNews)
        }
    } //desposables는 사용자가 스크린을 빠져나갈 경우 스트림을 취소하기 위해 필요함.
    ```
    - RxJava를 사용하면 메모리 누수도 없고, 취소가 가능하며, 스레드를 적절하게 사용할 수 있다.
    - 하지만 RxJava는 구현하기에 아주 복잡하다.
    - 실제로 RxJava를 도입하려면 수많은 코드를 바꿔야 한다.

5. 코틀린 코루틴 사용
    ``` kotlin
    val scope = CoroutineScope(Dispatchers.Main)

    fun onCreate() {
      scope.launch { updateNews() }
      scope.launch { updateProfile() }
    }

    suspend fun updateNews() {
      showProgressBar()
      val news = getNewsFromApi() //메인 스레드. 뉴스를 기다리는 중, 뉴스가 준비되면 실행됨
      val sortedNews = news.sortedByDescending { it.publishedAt }
      view.showNews(sortedNews)
      hideProgressBar()
    }

    //뉴스를 기다리면서 실행됨
    suspend fun updateProfile() {
      val user = getUserData()
      view.showUser(user)
    }
    ```
    - updateNews와 updateProfile 함수가 메인 스레드 내에서 각각의 코루틴으로 실행되는 걸 보여 준다. 두 함수가 한 스레드 내에서 넘나들며 실행될 수 있는 이유는 스레드가 블로킹되는 것이 아니라 코루틴이 중단되기 때문이다.
    - updateNews 함수가 네트워크 응답을 기다리는 동안, 메인 스레드는 updateProfile 함수가 사용한다. 이때 getUserData 호출은 사용자의 데이터가 캐싱되어 있기 때문에 중단되지 않는다고 가정한다. 따라서 updateProfile은 메인 스레드 내에서 멈추지 않고 실행될 수 있다.
    - 네트워크 응답이 오는 데 걸리는 시간이 프로필을 갱신하는 데 걸리는 시간보다 길기 때문에 메인 스레드가 사용되지 않고 기다리는 시간도 있다.
    - 데이터 전송이 완료되면, 메인스레드는 updateNews를 처리하는 코루틴에 의해 getNewsFromApi 이후 작업을 수행하게 된다.
    - 코틀린 코루틴이 도입한 핵심 기능은 코루틴을 특정 지점에서 멈추고 이후에 재개할 수 있다는 것이다.
    - 코루틴을 사용하면 우리가 짠 코드를 메인 스레드에서 실행하고 API에서 데이터를 얻어올 떄 잠깐 중단시킬 수도 있다.
    - 코루틴을 중단시켰을 때 스레드는 블로킹되지 않으며 뷰를 바꾸거나 다른 코루틴을 실행하는 등의 또 다른 작업이 가능하다.
    - 데이터가 준비되면 코루틴은 메인 스레드에서 대기하고 있다가 메인 스레드가 준비되면 멈춘 지점에서 다시 작업을 수행한다.

    ``` kotlin
    fun showNews() {
      viewModelScope.launch {
        val config = getConfigFromApi()
        val news = getNewsFromApi(config)
        val user = getUserFromApi()
        view.showNews(user, news)
      }
    }
    ```
    
    ``` kotlin
    fun showNews() {
      viewModelScope.launch {
        val config = async { getConfigFromApi() }
        val news = async { getNewsFromApi(config.await()) }
        val user = async {.getUserFromApi() }
        view.showNews(user.await(), news.await())
      }
    }
    ```
    - 3초 대신 2초만에 작업을 끝낼 수 있다.
    - `async`는 요청을 처리하기 위해 만들어진 코루틴을 즉시 시작사는 함수로, `await`와 같은 함수를 호출하여 결과를 기다린다.
    - 코드는 간단하며 요구 사항 또한 잘 구현되어 있다. 그리고 효율적으로 작동하며 메모리 누수가 일어나지도 않는다.
    - 코틀린 코루틴은 다양한 상황에서 쉽게 적용가능하며, 코틀린의 다른 기능 또한 활용할 수 있다는 장점이 있다. 예를 들어 for-루프나 컬렉션을 처리하는 함수를 사용할 때 블로킹 없이 구현 가능하다.
      ``` kotlin
      //모든 페이지를 동시에 받아온다.
      fun showAllNews() {
        viewModelScope.launch {
          val allNews = (0 until getNumberOfPages())
            .map { page -> async { getNewsFromApi(page) } }
            .flatMap { it.await() }
          view.showAllNews(allNews)
        }
      }
      ```

      ``` kotlin
      //페이지별로 순차적으로 받아온다.
      fun showAllNews() {
        viewModelScope.launch {
          val allNews = (0 until getNumberOfPages())
            .map { page -> async { getNewsFromApi(page) } }
            .flatMap { it.await() }
          view.showAllNews(allNews)
        }
      }
      ```

### 백엔드에서의 코루틴 사용
- 백엔드에서 코루틴을 사용하는 가장 큰 장점은 간결성이다. Rx-Java와 달리 코루틴을 도입하면 현재 코드에서 큰 변화가 없다.
- 스레드를 코루틴으로 바꾸는 대부분의 환경에서는 단지 `suspend` 제어자를 추가하는 것으로 충분하다.
- 코루틴을 도입하면 동시성을 쉽게 구현할 수 있고, 동시성을 테스트할 수 있으며, 코루틴을 취소할 수도 있다.
``` kotlin
suspend fun getArticle(
  articleKey: String,
  lang: Language
): ArticleJson? {
  return articleRepository.getArticle(articleKey, lang) ?.let { toArticleJaon(it) }
}
```
- 위와 같은 특징들을 제외하면 코루틴을 사용하는 가장 중요한 이유는 스레드를 사용하는 비용이 크기 때문이다.
- 스레드는 명시적으로 생성해야 하고, 유지되어야 하며, 스레드를 위한 메모리 또한 할당되어야 한다.
  - 대부분 스레드 스택의 기본 크기는 1MB이다. 자바 최적화 덕분에 스레드의 메모리 사용량이 1MB에 반드시 비례하지는 않지만, 스레드를 만들 때마다 여분의 메모리를 더 많이 사용하게 된다.
  - 즉, 10만 개의 요청에 대해 매번 스레드를 새로 띄운다면 스택 메모리만으로 대략 100 GB 정도??
- 수백만 명의 사용자들이 애플리케이션을 사용하고 있고 데이터베이스나 다른 서비스로부터 응답을 기다릴 때마다 블로킹하고 있다면, 스레드를 만들고, 유지하고, 동기화하는 모든 과정에서) 메모리와 프로세서 사용에 엄청난 비용이 들 것이다.
``` kotlin
//10만 개의 스레드를 만들고 1초동안 sleep(데이터베이스 또는 다른 서비스로부터 응답을 기다리는 상황)
fun main() {
  repeat(100_000) {
    thread {
      Thread.sleep(1000L)
      pring(".")
    }
  }
}
```
- 모든 점을 찍는 데 상당한 시간이 걸리거나 `OutOfMemoryError` 예외로 프로그램이 종료된다
- 많은 스레드를 실행하는 데 드는 비용이 크다

``` kotlin
//스레드 대신 코루틴을 사용했으며 스레드를 sleep 하는 대신 코루틴을 중단시킨다
fun main() = runBlocking {
  repeat(100_000) {
    launch {
      delay(1000L)
      pring(".")
    }
  }
}
```
- 프로그램을 실행하면 1초 기다린 뒤 모든 점을 출력하게 된다.
- 모든 코루틴을 시작하는 비용은 스레드와 비교가 되지 않을 정도로 저렴하여, 이를 인지할 수 없을 정도이다.


### 코루틴 정의
- 중단했다가 다시 실행할 수 있는 컴포넌트(component, 프로그래밍에서 재사용 가능한 각각의 독립된 모듈)라고 할 수 있다.
- 자바스크립트, 러스트, 파이썬과 같은 언어에서 사용하는 `async/await`, `제너레이터`와 같은 개념 또한 코루틴을 사용하지만 기능은 아주 제한적이다.

### 정리
- 코틀린 코루틴은 동시성 프로그래밍을 최대한 쉽게 구현할 수 있도록 도와준다.
- 스레드를 사용하는 비용을 크게 줄일 수 있다.
