# 시퀀스 빌더

- 코틀린에서는 제너레이터 대신 시퀀스를 생성할 때 사용하는 시퀀스 빌더를 제공하고 있다.
(코틀린은 시퀀스보다 더 좋은 방법인 플로우 빌더도 제공한다. 플로우(Flow)는 시퀀스와 비슷하지만 더 활용도가 높은 개념으로 책의 후반부에서 설명한다!)

- 코틀린의 시퀀스는 List나 Set과 같은 컬렉션이랑 비슷한 개념이지만, 필요할 때마다 값을 하나씩 계산하는 지연(Lazy) 처리를 한다.

- 시퀀스의 특징
  - 요구되는 연산을 최소한으로 수행한다
  - 무한정이 될 수 있다
  - 메모리 사용이 효율적이다.

- 이러한 특징 때문에 값을 순차적으로 계산하여 필요할 때 반환하는 빌더를 정의하는 것이 좋다.
  - 시퀀스는 sequence라는 함수를 이용해 정의한다.
  - 시퀀스의 람다 표현식 내부에서는 yield 함수를 호출하여 시퀀스의 다음 값을 생성한다
  ``` kotlin
  val seq = sequence {
    yield(1)
    yield(2)
    yield(3)
  }
  ```
  ``` kotlin
  fun main() {
    for (num in seq) {
      print(num)
    } //???
  }
  ```
    - sequence 함수: 짧은 DSL(Domain-Specific Languqage, 도메인 전용 언어) 코드
    - 인자: 수신객체 지정 람다 함수(suspend SequenceScope<T>.() -> Unit)
      - 람다 내부에서 수신 객체인 this는 SequenceScope<T>를 가리키는데, 이 객체는 yield 함수를 가지고 있다.
      - this가 암시적으로 사용되므로 yield(1)을 호출하면 this.yield(1)을 호출하는 것과 동일하다.
      - (수신 객체 지정 람다를 처음 접한다면 람다식과 DSL 생성을 먼저 공부하는 것을 추천한다! 람다식과 DSL은 코틀린 코루틴에서 광범위하게 사용되고 있기 때문..)

- 여기서 반드시 알아야 하는 것
  - 각 숫자가 미리 생성되는 대신, 필요할 때마다 생성된다는 점!!
  - 시퀀스 빌더 내부 그리고 시퀀스를 사용하는 곳에서 메시지를 출력하여 작동방식을 확인해보자
  ``` kotlin
  val seq = sequence {
    println("Generating first")
    yield(1)
    println("Generating second")
    yield(2)
    println("Generating third")
    yield(3)
    println("Done")
  }
  ```
  ``` kotlin
  fun main() {
    for (num in seq) {
      println("The next number is $num")
    }
  } //???
  ```

- 시퀀스의 작동 방식
  - 우선 첫 번째 수를 요청하면 빌더 내부로 진입 -> "Generating first" 출력 -> 1 반환
    - 이후 반복문에서 반환된 값을 받은 뒤 -> "Next number is 1" 출력
  - 여기서 반복문과 다른 결정적인 차이점!!
    - 이전에 다른 숫자를 찾기 위해 멈췄던 지점에서 다시 실행이 된다!!
    - 중단 체제가 없으면 함수가 중간에 멈췄다가, 나중에 중단된 지점에서 다시 실행되는 건 불가능하다.
    - 중단이 가능하기 때문에 main 함수와 시퀀스 제너레이터가 번갈아가면서 실행된다.

- 코루틴 없이 이런 게 가능할까?
  - 스레드가 이 일을 대신할 수도 있지만, 중단을 지원하는 스레드로 처리하려면 유지하고 관리하는데 막대한 비용이 든다.
  - 코루틴을 사용하면 더 빠르고 간단하게 중단이 가능하다.
  - (중단은 3장에서 어떤 방식으로 구현되었는지 살펴볼 예정..)

- 시퀀스 빌더가 사용된 몇 가지 예
  - 피보나치 수열과 같은 수학적 시퀀스 만들기
    ```kotlin
    val fibonacci: Seauence<BigInteger> = sequence {
      var first = 0.toBigInteger()
      var second = 1.toBigInteger()
      while (true) {
        yield(first)
        val temp = first //21
        first += second //34
        second = temp //21
      }
    }

    fun main() {
      print(fibonacci.take(10).toList())
    }
    //[0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
    ```

  - 난수나 임의의 문자열 만들기
    ```kotlin
    fun randomNumbers(
      seed: Long = System.currentTimeMillis()
    ): Sequence<Int> = sequence {
      val random = Random(seed)
      while (true) [
        yield(random.nextInt())
      ]
    }

    fun randomUniqueStrings(
      length: Int,
      seed: Long = System.currentTimeMillis()
    ): Sequence<String> = sequence {
      val random = Random(seed)
      val charPool = ('a'..'z') + ('A'..'Z') + ('0'..'9')
      while (true) {
        val randomString = (1..length)
          .map { i -> random.nextInt(charPool.size) }
          .map(charPool::get)
          .joinToString("");
        yield(randomString)
      }
    }.distinct()
    ```

- 시퀀스 빌더는 반환(yield)이 아닌 중단 함수를 사용하면 안 된다.
  - 실제로 시퀀스 빌더 내부에서 중단 연산을 호출할 수 없는데, 그 이유는 SequenceScope에 RestrictsSuspension 어노테이션이 있기 때문이다. RestrictsSuspension 어노테이션은 리시버가 SequenceScope가 아닐 경우에 중단 함수를 호출하는 것을 허용하지 않는다.
  - 중단이 필요하다면 데이터를 가져오기 위해 나중에 배울 플로우를 사용하는 것이 낫다
  - 플로우 빌더가 작동하는 방식은 시퀀스 빌더와 비슷하지만, 플로우는 여러 가지 코루틴 기능을 지원한다.
    ``` kotlin
    fun allUsersFlow(
      api: UserApi
    ): Flow<User> = flow {
      var page = 0
      do {
        val users = api.takePage(page++) //중단 함수
        emitAll(users)
      } while (!users.isNullOrEmpty())
    }
    ```

