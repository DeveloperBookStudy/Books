# 중단은 어떻게 작동할까?

- 중단 함수는 코틀린 코루틴의 핵심으로, 중단이 가능하다는 건 코틀린 코루틴의 다른 모든 개념의 기초가 되는 필수적인 요소이다.

- 코루틴을 중단한다는 건 실행을 중간에 멈추는 것을 의미
  - 비디오 게임을 하다가 멈추는 상황
  - 체크포인트에서 게임을 저장하고 종료한 뒤, 사용자와 컴퓨터는 각각 다른 일에 집중할 수 있다. 나중에 게임을 다시 하고 싶을 때 게임을 재개하고 저장한 체크포인트에서 시작하면 이전에 종료했던 순간부터 게임을 즐길 수 있다.

- 코루틴은 중단되었을 때 Continuation 객체를 반환한다 -> 이 객체는 게임을 저장하는 것과 비슷하다
  - Continuation을 이용하면 멈췄던 곳에서 다시 코루틴을 실행할 수 있다
  - 여기서 코루틴과 스레드의 차이점!
    - 스레드는 저장이 불가하고 멈추는 것만 가능하다.(이러한 점에서 코루틴이 훨씬 강력한 도구라 할 수 있다.)
    - 코루틴은 중단했을 때 어떤 자원도 사용하지 않는다. 
    - 코루틴은 다른 스레드에서 시작할 수 있고, Continuation 객체는 (이론상) 직렬화와 역직렬화가 가능하며 다시 실행될 수 있다.

## 재개
- 작업을 재개하려면 코루틴이 필요하다
- 코루틴은 이후에 소개될 `runBlocking`이나 `launch`와 같은 코루틴 빌더를 통해 만들 수 있다.
- 여기서는 중단 가능한 `main` 함수를 사용하겠다.
- 중단 함수는 말 그대로 코루틴을 중단할 수 있는 함수이다. 이는 중단 함수가 반드시 코루틴(또는 다른 중단 함수)에 의해 호출되어야 함을 의미한다.
- 중단 함수는 중단할 수 있는 곳이 필요하다. `main` 함수는 시작점이기 때문에 코틀린은 코루틴 내부에서 `suspend`가 붙은 `main` 함수를 샐행한다.

  ``` kotlin
  suspend fun main() {
    println("Before")

    println("After")
  }
  ```

- 만약 두 지점 사이에서 중단하면 어떻게 될까?

  ``` kotlin
  suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { } //두 지점 사이를 중단 지점으로 코틀린 라이브러리에서 제공하는 suspendCoroutine 함수를 사용

    println("After")
  }
  ```

- 어떻게 다시 실행시킬까? 앞에서 언급했던 Continuation은 어디 있을까?

  ``` kotlin
  suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
      println("Before too")
    } //인자로 들어간 람다 함수는 중단되기 전에 실행된다. 그리고 이 함수는 컨티뉴에이션 객체를 인자로 받는다.

    println("After")
  }
  ```

- `suspendCoroutine` 함수는 중단되기 전에 컨티뉴에이션 객체를 사용할 수 있다.
  - `suspendCoroutine`이 호출된 뒤에는 이미 중단되어 컨티뉴에이션 객체를 사용할 수 없기 때문에, 람다 표현식이 `suspendCoroutine` 함수의 인자로 들어가 중단되기 전에 실행되는 것입니다.

    ``` kotlin
    suspend fun main() {
      println("Before")

      suspendCoroutine<Unit> { continuation ->
        continuation.resume(Unit)
      } //컨티뉴에이션 객체를 애용해 코루틴을 중단한 후 곧바로 실행할 수 있다.

      println("After")
    } //코드만 보면 중단 후 곧바로 실행되었다고 생각되지만, 실제로는 최적화로 인해 곧바로 재개될 경우 아예 중단되지 않는다.
    ```
    - 코틀린 1.3 이후로 `Continuation` 클래스의 형태가 달라진다.원래는 `resume`과 `resumeException`을 사용했지만, 지금은 `Result`를 반환하는 `resumeWith` 함수 하나만 남아 있다.
    - `resume`과 `resumeException` 함수는 `resumeWith`를 사용하는 표준 라이브러리의 확장 함수가 되었다.
      ``` kotlin
      inline fun <T> Continuation<T>.resume(value: T): Unit =
        resumeWith(Result.success(value))

      inline fun <T> Continuation<T>.resumeException(
        exception: Throwable
      ): Unit = resumeWith(Result.failure(exception))
      ```

- `suspendCoroutine`에서 잠깐 동안 정지(sleep)된 뒤 재개되는 다른 스레드를 실행할 수도 있다

  ``` kotlin
  suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
      thread {
        println("Suspended")
        Thread.sleep(1000)
        continuation.resume(Unit)
        println("Resumed")
      }
    }

    println("After")
  }
  ```

- 다른 스레드가 재개하는 방식은 코루틴을 이해하는 데 중요하다.
- 정해진 시간 뒤에 코루틴을 다시 재개하는 함수를 만들 수 있으며, 이때 컨티뉴에이션 객체는 다음 코드와 같이 람다 표현식이 통제한다.

  ``` kotlin
  fun continueAfterSecond(continuation: Continuaion<Unit>) {
    thread {
      Thread.sleep(1000)
      continuation.resume(Unit)
    }
  }

  suspend fun main() {
    println("Before")

    suspendCoroutine<Unit> { continuation ->
      continueAfterSecond(continuation)
    }

    println("After")
  }
  ```

  -  위와 같은 방식으로 실행을 멈출 수 있지만, 만들어진 다음 1초 뒤에 사라지는 스레드는 불필요해 보인다. 스레드를 생성하는 비용이 상당히 많이 드는데 굳이 만들 필요가 있을까?
  - 더 좋은 방법은 알람 시계를 설정하는 것이다! 이를 위해 `JVM`이 제공하는 `ScheduledExecutorService`를 사용할 수 있다. 그리고 정해진 시간이 지나면 `continuation.resume(Unit)`을 호출하도록 알람을 설정할 수 있다.

    ``` kotlin
    private val executor =
      Executors.newSingleThreadScheduledExcutor {
        Thread(it, "schedular").apply { isDaemon = true }
      } //실제로 OS 스레드 1개를 생성해서, 그 위에서 작업을 스케줄링해 실행하는 실행기(executor)를 만든다.

    suspend fun main() {
      println("Before")

      suspendCoroutine<Unit> { continuation ->
        executor.schedule({
          continuation.resume(Unit)
        }, 1000, TimeUnit.MILLISECONDS)
      } //suspendCoroutine는 코루틴을 중단(suspend)하고, continuation 객체를 넘겨준다. -> executor.schedule를 사용하여, 위에서 반든 별도의 스레드가 1초 후에 continuation.resume(Unit)를 호출하게 된다.

      println("After")
    }
    ```

    - 잠깐 동안 중단할 수 있는 건 유용한 기능이므로 이를 delay 함수로 추출해 보자

      ``` kotlin
      private val executor =
        Executors.newSingleThreadScheduledExcutor {
          Thread(it, "schedular").apply { isDaemon = true }
        }

      suspend fun delay(timeMillis: Long): Unit =
        suspendCoroutine { cont ->
          executor.schedule({
            cont.resume(Unit)
          }, timeMillis, TimeUnit.MILLISECONDS)
        }

      suspend fun main() {
        println("Before")

        delay(1000)

        println("After")
      }
      ```
      - 여기서 이그제큐터는 스레드를 하나 생성하며, `delay` 함수를 사용하는 모든 코루틴이 이 스레드를 공유한다.
      - 핵심은 스레드를 쓰긴 하지만, 코루틴마다 스레드를 새로 만드는 게 아니라 `delay` 호출 시 하나의 스레드를 공유한다
      - 앞에서 설명한 대기할 대마다 하나의 스레드를 블로킹하는 방법보다 훨씬 나은 방식
      - 위 코드는 코틀린 코루틴 라이브러리에서 `delay`가 구현된 방식이랑 정확히 일치한다.

## 값으로 재개하기
- `resume` 함수에 왜 `Unit`을 인자로 넣을까?
- `suspendCoroutine`의 타입 인자로 `Unit`을 사용하는 이유는?
  - 이 두가지가 `Unit`으로 똑같다는 사실은 우연의 일치가 아니다. `Unit`은 함수의 리턴 타입이며, `Continuation`의 제네릭 타입 인자이기도 하다.

    ```kotlin
    val ret: Unit =
      suspendCoroutine<Unit> { cont: Continuation<Unit> ->
        cont.resume(Unit)
      }
    ```
  
- `suspendCoroutine`을 호출할 때 컨티뉴에이션 객체로 반환될 값의 타입을 지정할 수 있다.
- `resume`을 통해 반환되는 값은 반드시 지정된 타입과 같은 타입이어야 한다.

  ```kotlin
  suspend fun main() {
    val i: Int = suspendCoroutine<Int> { cont ->
      cont.resume(42)
    }
    println(i) //42

    val str: String = suspendCoroutine<String> { cont ->
      cont.resume("Some text")
    }
    println(str) //Some text

    val b: Boolean = suspendCoroutine<Boolean> { cont -> 
      cont.resume(true)
    }
    println(b) //true
  }
  ```
    - 코루틴에서는 값으로 재개하는 것이 자연스럽다.

- 특정 데이터를 얻을 때까지 중단되는 상황(왜부에 구현된 `requestUser` 콜백 함수 사용)
  - API를 호출해 네트워크 응답을 기다리는 것처럼 특정 데이터를 기다리려고 중단하는 상황은 자주 발생한다. 스레드는 특정 데이터가 필요한 지점까지 비즈니스 로직을 수행한다.
  - 이후 네트워크 라이브러리를 통해 데이터를 요청한다.
  - 코루틴이 없다면 스레드는 응답을 기다리고 있을 수밖에 없다.
    - 스레드를 생성하는 비용이 많이 들기도 하며, 특히 안드로이드의 메인 스레드처럼 중요하다면 스레드가 가만히 대기하고 있는 건 엄청난 낭비이다.
    - 코루틴이 있으면 중단함과 동시에 "데이터를 받고 나면, 받은 데이터를 `resume` 함수를 통해 보내줘." 라고 컨티뉴에이션 객체를 통해 라이브러리에 전달한다.
    - 그러면 스레드는 다른 일을 할 수 있다. 그리고 데이터가 도착하면 스레드는 코루틴이 중단된 지점에서 재개하게 된다.

  ```kotlin
  suspend fun main() {
    println("Before")
    val user = suspendCoroutine<User> { cont -> 
      requestUser { user ->
        cont.resume(user)
      }
    }
    println(user)
    println("After")
  }
  ```
  ```kotlin
  //suspendCoroutine을 직접 호출하지 않고, 중단 함수를 호출하도록 개선
  suspend fun requestUser(): User {
    return suspendCoroutine<User> { cont ->
      requestUser { user -> 
        cont.resume(user)
      }
    }
  }
  
  suspend fun main() {
    println("Before")
    val user = requestUser()
    println(user)
    println("After")
  }
  ```

- API가 데이터를 넘겨주는 대신 문제가 발생하면 어떻게 될까?
- 서비스가 종료되거나 에러로 응답이 어면 어떨까?
  - 이런 경우 데이터를 반환할 수 없으므로 코루틴이 중단된 곳에서 예외를 발생시켜야 한다.
  - 예외로 재개하는 방법이 필요할 때가 바로 이런 경우이다.

## 예외로 재개하기

- 우리가 사용하는 모든 함수는 값을 반환하거나 예외를 던진다. `suspendCoroutine` 또한 마찬가지이다.
  - `resume`이 호출될 때 `suspendCoroutine`은 인자로 들어온 데이터를 반환한다.
  - `resumeWithException`이 호출되면 중단된 지점에서 인자로 넣어준 예외를 던진다.

    ``` kotlin
    class MyException : Throwable("Just an exception")

    suspend fun main() {
      try {
        suspendCoroutine<Unit> { cont -> 
          cont.resumeWithException(MyException())
        }
      } catch (e: MyException) {
        println("Caught!")
      }
    }
    ```

    - 예를 들어 네트워크 관련 예외를 알릴 때 사용할 수 있다.

      ``` kotlin
      suspend fun requestUser(): User {
        return suspendCancellableCoroutine<User> { cont ->
          requestUser { resp ->
            if (resp.isSuccessful) {
              const.resume(resp.data)
            } else {
              val e = ApiException(
                resp.code,
                resp.message
              )
              cont.resumeWithException(e)
            }
          }
        }
      }

      suspend fun requestNews(): News {
        return suspendCancellableCoroutine<News> { cont ->
          requestNews(
            onSuccess = { news -> cont.resume(news) },
            onError = { e -> cont.resumeWithException(e) }
          )
        }
      }
      ```

## 함수가 아닌 코루틴을 중단시킨다.

- 여기서 강조하고 싶은 것은 함수가 아닌 코루틴을 중단시킨다는 것이다!!
  - 중단 함수는 코루틴이 아니고, 단지 코루틴을 중단할 수 있는 함수라 할 수 있다.

- 변수에 컨티뉴에이션 객체를 저장하고, 함수를 호출한 다음에 재개하는 상황을 보자.

  ``` kotlin
  //이렇게 구현하면 안 된다.
  val continuation: Continuation<Unit>? = null

  suspend fun suspendAndSetContinuation() {
    suspendCoroutine<Unit> { cont ->
      continuation = cont
    }
  }

  suspend fun main() {
    println("Before")

    suspendAndSetContinuation()
    continuation?.resume(Unit)

    println("After")
  }
  //Before
  ```

  ``` kotlin
  //메모리 누수가 발생할 수 있기 때문에 이렇게 구현하면 안 된다.
  val continuation: Continuation<Unit>? = null

  suspend fun suspendAndSetContinuation() {
    suspendCoroutine<Unit> { cont ->
      continuation = cont
    }
  }

  suspend fun main() = coroutineScope {
    println("Before")

    launch {
      delay(1000)
      continuation?.resume(Unit)
    }

    suspendAndSetContinuation()
    println("After")
  }
  
  //Before
  //(1초 후)
  //After
  ```