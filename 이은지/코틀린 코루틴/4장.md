# 코루틴의 실제 구현

## 코루틴의 내부 구현 및 동작 과정에서의 중요한 점
- 중단 함수는 함수가 시작할 때와 중단 함수가 호출되었을 때 상태를 가진다는 점에서 상태 머신`state machine`과 비슷하다.
- 컨티뉴에이션`continuation` 객체는 상태를 나타니는 숫자와 로컬 데이터를 가지고 있다.
- 함수의 컨티뉴에이션 객체가 이 함수를 부르는 다른 함수의 컨티뉴에이션 객체를 장식`decorate`한다. 그 결과, 모든 컨티뉴에이션 객체는 실행을 재개하거나 재개된 함수를 완료할 때 사용되는 콜 스택으로 사용된다.

## 컨티뉴에이션 전달 방식
> https://en.wikipedia.org/wiki/Continuation-passing_style

일단.. 무슨말인지 잘 모르겠음. 다음으로 넘어가보자..

## 아주 간단한 함수
```kotlin
suspend fun myFunction() {
  println("Before")
  delay(100) //중단 함수
  println("After")
}
```

### myFunction 함수의 시그니처(signature)
```kotlin
fun myFunction(continuation: Continuation<*>): Any
```

### 본체가 시작될 때 MyFunction은 파라미터인 continuation을 자신만의 컨티뉴에이션인 MyFunctionContinuation으로 포장한다
```kotlin
val continuation = MyFunctionContinuation(continuation)
```

### 단, 클래스에 포장이 없는 경우에만 클래스를 포장해야 한다. 만약 코루틴이 재실행되고 있으면 컨티뉴에이션 객체는 이미 래핑되어 있을 것이므로 컨티뉴에이션 객체를 그대로 둬야 한다.
```kotlin
val continuation = 
  if (continuation is MyFunctionContinuation) continuation
  else MyFunctionContinuation(continuation)
```

### 좀 더 간단하게 표현
```kotlin
val continuation = continuation as? MyFunctionContinuation
  ?: MyFunctionContinuation(continuation)
```

### MyFunction의 세부 구현
```kotlin
fun myFunction(continuation: Continuation<Unit>): Any {
  val continuation = continuation as? MyFunctionContinuation
    ?: MyFunctionContinuation(continuation)

  if (continuation.label == 0) {
    println("Before")
    continuation.label = 1
    if (delay(1000, continuation) == COROUTINE_SUSPENDED) {
      return COROUTINE_SUSPENDED
    }
  }
  if (continuation.label == 1) {
    println("After")
    return Unit
  }
  error("Impossible")
}
```
- 함수가 시작되는 지점은 함수의 시작점(함수가 처음 호출될 때)과 중단 이후 재개 시점(컨티뉴에이션이 `resume`을 호출할 때) 두 곳이다.
- 현재 상태를 저장하려면 `label`이라는 필드를 사용한다.
- 함수가 처음 시작될 때 이 값은 0으로 설정된다. 이후 중단되기 전에 다음 상태로 설정되어 코루틴이 재개될 시점을 알 수 있게 도와준다.
- 마지막으로 위 코드에서 중요한 부분은, `delay`에 의해 중단된 경우 `COROUTINE_SUSPENDED`가 반환되며, `myFunction`은 `COROUTINE_SUSPENDED`를 반환한다.
  - `myFunction`을 호출한 함수부터 시작해 콜 스택에 있는 모든 함수도 똑같다.(`COROUTINE_SUSPENDED`는 빌더 함수나 재개(`resume`) 함수에 도달할 때까지 전달된다.)
  - 따라서 중단이 일어나면 콜 스택에 있는 모든 함수가 종료되며, 중단된 코루틴을 실행하던 스레드를(다른 종류의 코루틴을 포함해) 실행 가능한 코드가 사용할 수 있게 된다.
    - => 아직 명확하게 이해가 되지는 않는다..
- `delay` 호출이 `COROUTINE_SUSPENDED`를 반환하지 않았다면 어떻게 될까?
- 그렇지는 않겠지만 대신에 `Unit`을 반환하면 어떨까?
  - `delay`의 반환값이 `Unit`일 경우 다음 상태로 바뀌고 다른 함수와 다름없는 동작을 할 것이다.

### 익명 클래스(anonymous class)로 구현된 컨티뉴에이션 객체(=> 코드가 생소함.. 이해가 잘 안되는 부분..)
```kotlin
cont = object : ContinuationImpl(continuation) {
  var result: Any? = null
  var label = 0

  override fun invokeSuspend(`$result`: Any?): Any? {
    this.result = `$result`;
    return myFunction(this);
  }
}
```

### 지금까지 설계한 함수를 간략화한 최종 모습
```kotlin
fun myFunction(continuation: Continuation<Unit>): Any {
  val continuation = continuation as ? MyFunctionContinuation
    ?: MyFunctionContinuation(continuation)

  if (continuation.label == 0) {
    println("Before")
    continuation.label = 1
    if (delay(1000, continuation) == COROUTINE_SUSPENDED) {
      return COROUTINE_SUSPENDED
    }
  }
  if (continuation.label == 1) {
    println("After")
    return Unit
  }
  error("Impossible")
}

class MyFunctionContinuation(
  val completion: Continuation<Unit>
) : Continuation<Unit> {
  override val context: CoroutineContext
    get() = completion.context

    var label = 0
    var result: Result<Any>? = null

    override fun resumeWith(result: Result<Unit>) {
      this.result = result
      val res = try {
        val r = myFunction(this)
        if (r == COROUTINE_SUSPENDED) return
        Result.success(r as Unit)
      } catch (e: Throwable) {
        Result.failure(e)
      }
      completion.resumeWith(res)
    }
}
```