# 코루틴의 실제 구현

## 코루틴의 내부 구현과 동작 과정에 대해 이해하는 데 있어서 중요한 점
- 중단 함수는 함수가 시작할 때와 중단 함수가 호출되었을 때 상태를 가진다는 점에서 상태 머신`state machine`과 비슷하다.
- 컨티뉴에이션`continuation` 객체는 상태를 나타니는 숫자와 로컬 데이터를 가지고 있다.
- 함수의 컨티뉴에이션 객체가 이 함수를 부르는 다른 함수의 컨티뉴에이션 객체를 장식`decorate`한다. 그 결과, 모든 컨티뉴에이션 객체는 실행을 재개하거나 재개된 함수를 완료할 때 사용되는 콜 스택으로 사용된다.

## 컨티뉴에이션 전달 방식
중단 함수가 구현될 수 있는 수많은 방법 중에서 코틀린 팀은 컨티뉴에이션 전달 방식 `continuation-passing style`을 택했다.
> https://en.wikipedia.org/wiki/Continuation-passing_style

프로그램의 제어 흐름을 다음에 무엇을 할지를 나타내는 함수(컨티뉴에이션)로 명시적으로 넘기는 코드 스타일이다.  
함수는 값을 `return`하지 않고, 계산 결과를 들고 `k`를 호출한다.
### Direct Style
```kotlin
fun add1(x: Int): Int = x + 1
fun twice(x: Int): Int = add1(add1(x)) //return으로 이어 붙임
```

### CPS Style
```kotlin
//k: (Int) -> Unit이 다음에 할 일
fun add1(x: Int, k: (Int) -> Unit) {
  k(x + 1) //Int 결과를 결과를 return하지 않고 k에 넘김
}
fun twice(x: Int, k: (Int) -> Unit) {
  add1(x) { y -> //x+1 결과를 y로 받아
    add1(y, k) //y+1 결과를 k로 넘김
  }
}
```
`return`이 아니라 다음에 할 일 `k`를 호출하기 때문에, 지금이 아니라 나중에 이어갈 수 있다. 코루틴의 내부 모델(중단/재개)에서 사용되는 방식이다.

이전에 설명했던 것처럼 컨티뉴에이션은 함수에서 함수로 인자를 통해 전달된다. 관례상 컨티뉴에이션은 마지막 파라미터로 전달된다.

### 중단 함수 내부
``` kotlin
suspend fun getUser(): User?
suspend fun setUser(user: User)
suspend fun checkAvailability(flight: Flight): Boolean

//자세히 들여다 보면
fun getUser(continuation: Continuation<*>): Any?
fun setUser(user: User, continuation: Continuation<*>): Any
fun checkAvailability(
  flight: Flight,
  continuation: Continuation<*>
): Any
```
중단 함수 내부를 들여다 보면 원래 선언했던 형태와 반환 타입이 달라졌다는 걸 알 수 있다.
> `Any` 또는 `Any?`로 바뀐 이유는 뭘까?

이는 중단 함수를 실행하는 도중에 중단되면 선언된 타입의 값을 반환하지 않을 수 있기 때문이다. 이때 중단 함수는 나중에 살펴볼 특별한 마커(marker)인 `COROUTINE_SUSPENDED`를 반환한다.
- 지금은 `getUser` 함수가 `User?` 또는 `COROUTINE_SUSPENDED`를 반환할 수 있기 때문에 결과 타입이 `User?`와 `Any`의 가장 가까운 슈퍼타입(supertype)인 `Any?`로 지정되었다는 것만 확인하자.


## 아주 간단한 함수
```kotlin
suspend fun myFunction() {
  println("Before")
  delay(100) //중단 함수
  println("After")
}
```

### myFunction 함수의 시그니처(signature)
`myFunction`함수의 시그니처를 다음과 같이 추론할 수 있다.
```kotlin
fun myFunction(continuation: Continuation<*>): Any
```
이 함수는 상태를 저장하기 위해 자신만의 컨티뉴에이션 객체가 필요하다.
- 이를 `myFunctionContinuation`이라 하겠다(실제로 컨티뉴에이션은 이름이 없는 객체의 표현식이지만 이해를 돕기 위해 이름을 붙였다).

### MyFunctionContinuation으로 포장
본체가 시작될 때 `MyFunction`은 파라미터인 `continuation`을 자신만의 컨티뉴에이션인 `myFunctionContinuation`으로 포장한다.
```kotlin
val continuation = MyFunctionContinuation(continuation)
```
단, 클래스에 포장이 없는 경우에만 클래스를 포장해야 한다. 만약 코루틴이 재실행되고 있으면 컨티뉴에이션 객체는 이미 래핑되어 있을 것이므로 컨티뉴에이션 객체를 그대로 둬야 한다.
```kotlin
val continuation = 
  if (continuation is MyFunctionContinuation) continuation
  else MyFunctionContinuation(continuation)
```
- 실제 작동하는 방식은 중단 함수가 재귀를 지원하기 위해, `label`의 첫 번째 비트가 바뀌고 중단 함수가 바뀐 값을 확인하는 과정이 있어 약간 더 복잡하다. 좀더 간단한 설명을 위해 이 과정은 생략되었다.

다음과 같이 간단하게 만들 수도 있다.
```kotlin
val continuation = continuation as? MyFunctionContinuation
  ?: MyFunctionContinuation(continuation)
```

### 다시 아주 간단한 함수
이제 함수의 본체를 다시 보자.
```kotlin
suspend fun myFunction() {
  println("Before")
  delay(100) //중단 함수
  println("After")
}
```
함수가 시작되는 지점은 함수의 시작점(함수가 처음 호출될 때)과 중단 이후 재개 시점(컨티뉴에이션이 `resume`을 호출할 때) 두 곳이다.  

현재 상태를 저장하려면 `label`이라는 필드를 사용한다.
- 함수가 처음 시작할 때 이 값은 0으로 설정된다.
- 이후에는 중단되기 전에 다음 상태로 설정되어 코루틴이 재개될 시점을 알 수 있게 도와준다.

### MyFunction의 세부 구현
`MyFunction`의 세부 구현을 간단하게 표현하면 다음과 같다.
```kotlin
fun myFunction(continuation: Continuation<Unit>): Any {
  val continuation = continuation as? MyFunctionContinuation
    ?: MyFunctionContinuation(continuation)

  if (continuation.label == 0) {
    println("Before")
    continuation.label = 1
    if (delay(1000, continuation) == COROUTINE_SUSPENDED) {
      return COROUTINE_SUSPENDED
    }
  }
  if (continuation.label == 1) {
    println("After")
    return Unit
  }
  error("Impossible")
}
```
위 코드에서 중요한 부분은, `delay`에 의해 중단된 경우 `COROUTINE_SUSPENDED`가 반환되며, `myFunction`은 `COROUTINE_SUSPENDED`를 반환한다.
  - `myFunction`을 호출한 함수부터 시작해 콜 스택에 있는 모든 함수도 똑같다(좀더 구체적으로 설명하면, `COROUTINE_SUSPENDED`는 빌더 함수나 '재개(`resume`)' 함수에 도달할 때까지 전달이 된다). 따라서 중단이 일어나면 콜 스택에 있는 모든 함수가 종료되며, 중단된 코루틴을 실행하던 스레드를 (다른 종류의 코루틴을 포함해) 실행 가능한 코드가 사용할 수 있게 된다.

> `delay` 호출이 `COROUTINE_SUSPENDED`를 반환하지 않았다면 어떻게 될까? 그렇지는 않겠지만 대신에 `Unit`을 반환한다면?

`delay`의 반환값이 `Unit`일 경우 다음 상태로 바뀌도 다른 함수와 다름없는 동작을 할 것이다.

``` text
내 생각에는, 여기가 코루틴의 중요한 이점이 드러나는 부분이 아닐까 싶다. delay가 COROUTINE_SUSPENDED를 반환하면 코루틴만 중단되고 스레드는 비워져서 다른 작업이 그 스레드를 쓸 수 있다. 덕분에 적은 스레드로도 많은 동시 작업(주로 IO 대기 관련) 처리가 가능해질 것 같다.

delay가 Unit을 반환한다면, 즉, 실제로는 중단이 일어나지 않는다면, 호출한 suspend 함수가 그냥 일반 함수처럼 현재 스레드를 계속 써서 동기적으로 계속 실행될 것이다.
```

### 익명 클래스(anonymous class)로 구현된 컨티뉴에이션 객체
이제 익명 클래스로 구현된 컨티뉴에이션 객체에 대해 알아보자. 간단하게 나타내면 다음과 같다.
```kotlin
cont = object : ContinuationImpl(continuation) {
  var result: Any? = null
  var label = 0

  override fun invokeSuspend(`$result`: Any?): Any? {
    this.result = `$result`;
    return myFunction(this);
  }
}
```

### 지금까지 설계한 함수를 간략화한 최종 모습
가독성을 위해 컨티뉴에이션 객체를 `MyFunctionContinuation`이라는 클래스로 나타내겠다. `ContinuationImpl`의 본체를 내부로 옮겨 상속 관계는 숨기도록 했다.
```kotlin
fun myFunction(continuation: Continuation<Unit>): Any { //1. myFunction(parent) 최초 호출
  val continuation = continuation as? MyFunctionContinuation
    ?: MyFunctionContinuation(continuation) //2. 이 프레임의 상태 정보를 담을 컨티뉴에이션으로 감싸기

  if (continuation.label == 0) {
    println("Before")
    continuation.label = 1 //다음 재진입 지점 설정
    if (delay(1000, continuation) == COROUTINE_SUSPENDED) {
      return COROUTINE_SUSPENDED //3. 중단 발생
    }
    //여기까지 온 경우는 중단이 없는 경우
  }
  if (continuation.label == 1) {
    println("After")
    return Unit //6. After 출력 및 Unit 반환
  }
  error("Impossible")
}

class MyFunctionContinuation(
  val completion: Continuation<Unit> //이 프레임이 끝나면 결과를 넘길 상위 객체
) : Continuation<Unit> {
  override val context: CoroutineContext
    get() = completion.context

    var label = 0 //상태 머신의 분기 라벨
    var result: Result<Any>? = null //직전 중단 지점의 결과

    override fun resumeWith(result: Result<Unit>) { //4. 1초 후 재개
      this.result = result
      val res = try {
        val r = myFunction(this) //5. myFunction(this) 재호출 -> label == 1로 분기 실행
        if (r == COROUTINE_SUSPENDED) return //다시 중단되는 경우
        Result.success(r as Unit)
      } catch (e: Throwable) {
        Result.failure(e)
      }
      completion.resumeWith(res) //7. 상위 컨티뉴에이션에 결과를 전파
    }
}
```

## 상태를 가진 함수
