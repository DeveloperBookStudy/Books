# 6장 코루틴 빌더
중단 함수는 컨티뉴에이션 객체를 다른 중단 함수로 전달해야 한다. 따라서 중단 함수가 일반 함수를 호출하는 것은 가능하지만, 일반 함수가 중단 함수를 호출하는 것은 불가능하다.
``` kotlin
suspend fun suspendingFun() {
  //...
  normalFun()
} //가능

fun normalFun() {
  /...
  suspendingFun() //compile 오류 발생(Suspend function 'suspendingFun' should be called only from a coroutine or another suspend function)
} //불가능
```
중단 함수를 연속으로 호출하면 시작되는 지점이 반드시 있다. 코루틴 빌더(`coroutine builder`)가 그 역할을 하며, 일반 함수와 중단 가능한 세계를 연결시키는 다리가 된다.
> `kotlinx.coroutines` 라이브러리가 제공하는 세 가지 필수적인 코루틴 빌더를 탐색해 봅시다.
- launch
- runBlocking
- async

## launch 빌더
> `launch`가 작동하는 방식은 `thread` 함수를 호출하여 새로운 스레드를 시작하는 것과 비슷하다. 코루틴을 시작하면 불꽃놀이를 할 때 불꽃이 하늘 위로 각자 퍼지는 것처럼 별개로 실행된다.
``` kotlin
fun main() {
  GlobalScope.launch {
    delay(1000L)
    println("World!")
  }
  GlobalScope.launch {
    delay(1000L)
    println("World!")
  }
  GlobalScope.launch {
    delay(1000L)
    println("World!")
  }
  println("Hello,")
  Thread.sleep(2000L)
}
//Hello,
//(1초 후)
//World!
//World!
//World!
```
- `launch` 함수는 `CoroutineScope` 인터페이스의 확장 함수이다. `CoroutineScope` 인터페이스는 부모 코루틴과 자식 코루틴 사이의 관계를 정립하기 위한 목적으로 사용되는 구조화된 동시성의 핵심이다.(구조화된 동시성에 대해서는 조금 뒤에 다룰 예정)
- 지금은 `GlobalScope` 객체에서 `launch`를 호출하는 방식을 사용하지만, 실제로는 이런 방식은 좋다고 보기 힘들기 때문에, 실제 현업에서는 `GlobalScope`의 사용을 지양해야 한다.
- `delay` 가 스레드를 블록시키지 않고 코루틴을 중단시키기 때문에, 마지막에 `Thread.sleep`을 통해 스레드를 블로킹 하지 않으면 코루틴을 실행하자 마자 할 일이 없어져 그대로 종료된다.(메인 함수는 코루틴을 실행하자마자 끝나버린다.)
  - 3장 '중단은 어떻게 작동할까?'에서 `delay`가 정해진 시간 뒤에 재개하기 위한 타이머만 설정한 뒤 그 시간동안 코루틴의 실행을 멈춘다는 걸 기억해보자.

## runBlocking 빌더
> 코루틴이 스레드를 블로킹하지 않고 작업을 중단시키기만 하는 것이 일반적인 법칙이나, 블로킹이 필요한 경우도 있다. 메인 함수의 경우 프로그램을 너무 빨리 끝내지 않기 위해 스레드를 블로킹해야 한다. 이럴 떄 `runBlocking`을 사용하면 된다.

```kotlin
fun main() {
  runBlocking {
    delay(1000)
    println("World!")
  }
  runBlocking {
    delay(1000)
    println("World!")
  }
  runBlocking {
    delay(1000)
    println("World!")
  }
  println("Hello,")
}
//(1초후)
//World!
//(1초후)
//World!
//(1초후)
//World!
//Hello,
```
- `runBlocking`은 아주 특이한 코루틴 빌더로, 코루틴이 중단되었을 경우, 새로운 코루틴을 실행한 뒤 완료될 때까지 현재 스레드를 중단 가능한 상태로 블로킹한다. 따라서 `runBlocking` 내부에서 `delay(1000L)`을 호출하면 `Thread.sleep(1000L)`과 비슷하게 작동한다.

### runBlocking이 사용되는 두 가지 경우
1. 프로그램이 끝나는 걸 방지하기 위해 스레드를 블로킹할 필요가 있는 메인 함수
  ```kotlin
  fun main() = runBlocking {
    // ...
  }
  ```
2. 같은 이유로 스레드를 블로킹할 필요가 있는 유닛 테스트
  ```kotlin
  Class MyTests {

    @Test
    fun `a test`() = runBlocking {

    }
  }
  ```

### Thread.sleep(2000)을 runBlocking 안에서 delay(2000)을 사용하는 방식으로 대체할 수 있다.
뒤에 나올 구조화된 동시성에 대해 공부하면 이 방식이 좀 더 유용하다는 걸 알 수 있다.
```kotlin
fun main() = runBlocking {
  GlobalScope.launch {
    delay(1000L)
    println("World!")
  }
  GlobalScope.launch {
    delay(1000L)
    println("World!")
  }
  GlobalScope.launch {
    delay(1000L)
    println("World!")
  }
  println("Hello,")
  delay(2000L) //여전히 필요함.
}
//Hello,
//(1초 후)
//World!
//World!
//World!
```
- `runBlocking`은 코루틴 빌더로 중요하게 사용되었지만 현재는 거의 사용되지 않느다. 유닛 테스트에서는 `runTest`가 주로 사용되는데, 이는 나중에 다시 살펴볼 예정이다.
- 메인 함수는 `runBlocking` 대신에 `suspend`를 붙여 중단 함수로 만드는 방법을 주로 사용한다.
```kotlin
suspend fun main {
  GlobalScope.launch {
    delay(1000L)
    println("World!")
  }
  GlobalScope.launch {
    delay(1000L)
    println("World!")
  }
  GlobalScope.launch {
    delay(1000L)
    println("World!")
  }
  println("Hello,")
  delay(2000L)
}
//Hello,
//(1초 후)
//World!
//World!
//World!
```

## async 빌더
> `async` 빌더는 `launch`와 비슷하지만 값을 생성하도록 설계되어 있다. 이 값은 람다 표현식에 의해 반환되어야 한다. `async` 함수는 `Deffered<T>` 타입의 객체를 리턴하며, 여기서 `T`는 생성되는 값의 타입이다. `Deffered`에는 작업이 끝나면 값을 반환하는 중단 메서드인 `await`가 있다.

다음 예제를 보면 `Deffered<Int>`가 반환되고 await가 Int 타입인 42를 반환하기 때문에 생성되는 값은 타입이 Int인 42가 되는 걸 확인할 수 있다.
```kotlin
fun main() = runBlocking {
  val resultDeferred: Deffered<Int> = GlobalScope.async {
    delay(1000L)
    42
  }
  // 다른 작업을 합니다...
  val result: Int = resultDeferred.await() //(1초 후)
  println(result) //42
}
```

> `launch` 빌더와 비슷하게 `async` 빌더는 호출되자마자 코루틸을 즉시 시작한다. 따라서 몇 개의 작업을 한번에 시작하고 모든 결과르 한거번에 기다릴 때 사용한다. 반환된 `Deferred`는 값이 생성되면 해당 값을 내부에 저장하기 떄문에 `await`에서 값이 반환되는 즉시 값을 사용할 수 있다.
```kotlin
fun main() = runBlocking {
  val res1 = GlobalScope.async {
    delay(1000L)
    "Text 1"
  }
  val res2 = GlobalScope.async {
    delay(3000L)
    "Text 2"
  }
  val res3 = GlobalScope.async {
    delay(2000L)
    "Text 3"
  }
  println(res1.await())
  println(res2.await())
  println(res3.await())
}
//(1초 후)
//Text 1
//(2초 후)
//Text 2
//Text 3
```

- async 빌더가 작동하는 방식은 launch와 비슷하지만, 값을 반환한다는 추가적인 특징이 있다. launch 함수를 async로 대체해도 코드는 여전히 똑같은 방식으로 작동하지만, 그렇게 하면 안된다!
- async는 값을 생성할 때 사용되며, 값이 피요하지 않을 때는 launch를 써야 한다.
```kotlin
fun main() = runBlocking {
  //이렇게 작성하지 마세요!
  //async를 launch로 잘못 사용한 경우입니다.
  GlobalScope.async {
    delay(1000L)
    println("World!")
  }
  print("Hello,")
  delay(2000L)
}
//Hello,
//(1초 후)
//World!
```

- async 빌더는 두 가지 다른 곳에서 데이터를 얻어와 합치는 경우처럼, 두 작업을 병렬로 시랭할 때 주로 사용된다.
``` kotlin
scope.launch {
  val new = async {
    newsRepo.getNews()
      .sortedByDescending { it.date }
  }
  val newsSummary = newsRepo.getNewsSummary()
  view.showNews (
    newsSummary,
    news.await()
  )
}
```

## 구조화된 동시성
코루틴이 GlobalScope에서 시작되었다면 프로그램은 해당 코루틴을 기다리지 않는다. 코루틴은 어떤 스레드도 블록하지 않기 때문에 프로그램이 끝나는 걸 막을 방법이 없다.

## 현업에서의 코루틴 사용

## coroutineScope 사용하기

## 요약

## 총평