# 출력 파서

출력 파서(Output Parser) 는 모델이 생성한 텍스트를 원하는 데이터 구조로 변환해주는 컴포넌트이다.

출력 파서를 사용하면 LLM의 응답을 구조화된 데이터로 받거나 원하는 정보를 손쉽게 추출하는 것이 가능하다. 반면 출력 파서를 사용하지 않으면 자유 형식의 텍스트 출력을 수동으로 해석하고 필요한 정보를 추출해야 하므로 자동화가 어렵다.

 - 구조화: LLM의 자유 형식 텍스트 출력을 구조화된 데이터로 변환해 정보를 체계적으로 관리
 - 일관성: 출력 형식을 일관되게 유지하여 후속 처리나 데이터 조회가 쉽고 효율적
 - 유연성: JSON, 리스트, 딕셔너리 등 다양한 출력 형식으로 변환 가능하여 유연성 제공

<br/>

## 1. PydanticOutputParser

Pydantic은 파이썬에서 데이터 유효성을 검사하고, 데이터를 구조화된 형식으로 관리하는 데 유용한 라이브러리이다.

PydanticOutputParser는 언어 모델의 출력을 구조화된 정보로 변환하는 데 도움을 주는 클래스로, 단순 텍스트 응답 대신 언어 모델ㄹ의 출력을 특정 데이터 모델에 맞게 변환하여 정보를 더 쉽게 처리하고 활용할 수 있다.

 - get_format_instructions(): 언어 모델이 출력해야 할 정보의 형식을 정의하는 지침을 제공.
 - parses(): 언어 모델의 출력을 받아 이를 특정 구조로 분석하고 변환.

<br/>

### 1-1. 예시

 - `내용`
```python
email_conversation = """From: 김철수 (chulsoo.kim@bikecorporation.me)
To: 이은채 (eunchae@teddyinternational.me)
Subject: "ZENESIS" 자전거 유통 협력 및 미팅 일정 제안

안녕하세요, 이은채 대리님,

저는 바이크코퍼레이션의 김철수 상무입니다. 최근 보도자료를 통해 귀사의 신규 자전거 "ZENESIS"에 대해 알게 되었습니다. 바이크코퍼레이션은 자전거 제조 및 유통 분야에서 혁신과 품질을 선도하는 기업으로, 이 분야에서의 장기적인 경험과 전문성을 가지고 있습니다.

ZENESIS 모델에 대한 상세한 브로슈어를 요청드립니다. 특히 기술 사양, 배터리 성능, 그리고 디자인 측면에 대한 정보가 필요합니다. 이를 통해 저희가 제안할 유통 전략과 마케팅 계획을 보다 구체화할 수 있을 것입니다.

또한, 협력 가능성을 더 깊이 논의하기 위해 다음 주 화요일(1월 15일) 오전 10시에 미팅을 제안합니다. 귀사 사무실에서 만나 이야기를 나눌 수 있을까요?

감사합니다.

김철수
상무이사
바이크코퍼레이션
"""
```

 - `응답 단순 출력`
```python
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import PydanticOutputParser
from pydantic import BaseModel, Field

llm = ChatOpenAI(temperature=0, model_name="gpt-4o")
prompt = PromptTemplate.from_template(
    "다음의 이메일 내용중 중요한 내용을 추출해 주세요.\n\n{email_conversation}"
)
answer = chain.stream({"email_conversation": email_conversation})
output = stream_response(answer, return_output=True)

"""
**중요한 내용 추출:**

1. **발신자:** 김철수 (chulsoo.kim@bikecorporation.me)
2. **수신자:** 이은채 (eunchae@teddyinternational.me)
3. **제목:** "ZENESIS" 자전거 유통 협력 및 미팅 일정 제안
4. **요청 사항:**
   - ZENESIS 모델에 대한 상세한 브로슈어 요청 (기술 사양, 배터리 성능, 디자인 정보 포함)
5. **미팅 제안:**
   - 날짜: 다음 주 화요일 (1월 15일)
   - 시간: 오전 10시
   - 장소: 귀사 사무실
"""
```

 - `출력 파서 이용`
```python
class EmailSummary(BaseModel):
    person: str = Field(description="메일을 보낸 사람")
    email: str = Field(description="메일을 보낸 사람의 이메일 주소")
    subject: str = Field(description="메일 제목")
    summary: str = Field(description="메일 본문을 요약한 텍스트")
    date: str = Field(description="메일 본문에 언급된 미팅 날짜와 시간")


# PydanticOutputParser 생성
parser = PydanticOutputParser(pydantic_object=EmailSummary)
print(parser.get_format_instructions())
"""
The output should be formatted as a JSON instance that conforms to the JSON schema below.

As an example, for the schema {"properties": {"foo": {"title": "Foo", "description": "a list of strings", "type": "array", "items": {"type": "string"}}}, "required": ["foo"]}
the object {"foo": ["bar", "baz"]} is a well-formatted instance of the schema. The object {"properties": {"foo": ["bar", "baz"]}} is not well-formatted.

Here is the output schema:
...
"""


# PromptTemplate 생성
prompt = PromptTemplate.from_template(
    """
You are a helpful assistant. Please answer the following questions in KOREAN.

QUESTION:
{question}

EMAIL CONVERSATION:
{email_conversation}

FORMAT:
{format}
"""
)

# format 에 PydanticOutputParser의 부분 포맷팅(partial) 추가
prompt = prompt.partial(format=parser.get_format_instructions())
chain = prompt | llm

# chain 을 실행하고 결과를 출력합니다.
response = chain.stream(
    {
        "email_conversation": email_conversation,
        "question": "이메일 내용중 주요 내용을 추출해 주세요.",
    }
)

# 결과는 JSON 형태로 출력됩니다.
output = stream_response(response, return_output=True)

# PydanticOutputParser 를 사용하여 결과를 파싱합니다.
structured_output = parser.parse(output)
print(structured_output)

"""
EmailSummary(person='김철수', email='chulsoo.kim@bikecorporation.me', subject='"ZENESIS" 자전거 유통 협력 및 미팅 일정 제안', summary='바이크코퍼레이션의 김철수 상무가 테디인터내셔널의 이은채 대리에게 신규 자전거 "ZENESIS" 모델에 대한 상세한 브로슈어 요청 및 협력 논의를 위한 미팅을 제안함. 미팅 일정은 1월 15일 화요일 오전 10시로 제안됨.', date='1월 15일 화요일 오전 10시')
"""
```

 - `출력 파서 체인 구성`
    - 앞서 프롬프트와 LLM을 묶어서 체인을 구성하였다.
    - 출력 파서 자체를 체인에 추가할 수도 있다.
```python
chain = prompt | llm | parser

response = chain.invoke(
    {
        "email_conversation": email_conversation,
        "question": "이메일 내용중 주요 내용을 추출해 주세요.",
    }
)
```
<br/>

 - `with_structured_output() 바인딩`
    - with_structured_output()을 사용하여 출력 파서를 추가하면, 출력을 Pydantic 객체로 변환할 수 있다.
    - with_structured_output() 함수는 stream() 기능을 지원하지 않는다.
```python
llm_with_structured = ChatOpenAI(
    temperature=0, model_name="gpt-4o"
).with_structured_output(EmailSummary)

answer = llm_with_structered.invoke(email_conversation)

# 응답 결과
"""
EmailSummary(person='김철수', email='chulsoo.kim@bikecorporation.me', subject='"ZENESIS" 자전거 유통 협력 및 미팅 일정 제안', summary='김철수 상무는 바이크코퍼레이션에서 이은채 대리에게 ZENESIS 자전거 모델에 대한 브로슈어와 기술 사양, 배터리 성능, 디자인 정보를 요청하며, 유통 전략과 마케팅 계획을 구체화하기 위해 다음 주 화요일(1월 15일) 오전 10시에 미팅을 제안했습니다.', date='1월 15일 오전 10시')
"""
```
<br/>

## 2. CommaSeparatedListOutputParser (콤마 구분자 출력 파서)

CommaSeparatedListOutputParser는 쉼표로 구분된 항목을 리스트 형식으로 처리하는 출력 파서이다.

이 파서를 사용하면, 요청된 정보를 문자열이 아닌 정형화된 리스트 형태로 제공할 수 있어 후처리 작업이 용이하다. 리스트 형식은 인덱스를 통해 필요한 데이터에 쉽게 접근할 수 있으므로, 여러 개의 데이터 포인트나 항목을 나열할 때 정보를 효과적으로 정리하고 전달할 수 있다.

### 2-1. 예시

 - `체인 구성`
```python
from langchain_core.output_parsers import CommaSeparatedListOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# 콤마로 구분된 리스트 출력 파서 초기화
output_parser = CommaSeparatedListOutputParser()

# 출력 형식 지침 가져오기
format_instructions = output_parser.get_format_instructions()
# 프롬프트 템플릿 설정
prompt = PromptTemplate(
    # 주제에 대한 다섯 가지를 나열하라는 템플릿
    template="List five {subject}.\n{format_instructions}",
    input_variables=["subject"],  # 입력 변수로 'subject' 사용
    # 부분 변수로 형식 지침 사용
    partial_variables={"format_instructions": format_instructions},
)

# ChatOpenAI 모델 초기화
model = ChatOpenAI(temperature=0)

# 프롬프트, 모델, 출력 파서를 연결하여 체인 생성
chain = prompt | model | output_parser
```
<br/>

 - `LLM 요청`
```python
# "대한민국 관광명소"에 대한 체인 호출 실행
chain.invoke({"subject": "대한민국 관광명소"})

# 응답 결과
"""
['경복궁', '인사동', '부산 해운대해수욕장', '제주도', '남산타워']
"""

# 스트림을 순회합니다.
for s in chain.stream({"subject": "대한민국 관광명소"}):
    print(s)  # 스트림의 내용을 출력합니다.
```
<br/>

## 3. StructuredOuputParser (구조화된 출력 파서)

StructuredOuputParser는 LLM에 대한 답변을 딕셔너리 형식으로 정의하고, 키와 값의 쌍으로 여러 필드를 반환하는 데이터 구조화에 유용하다.

Pydantic/JSON 파서가 더 강력하지만, 이는 GPT나 Claude 모델보다 인텔리전스가 낮은 로컬 모델에서 원하는 형식으로 데이터가 잘 안나올 수 있다. 이떄, StructuredOuputParser를 이용할 수 있다.

<br/>

### 3-1. 예시

 - `체인 구성`
    - ResponseSchema 클래스를 사용하여 사용자의 질문에 대한 답변과 사용된 소스에 대한 설명을 포함하는 응답 스키마 정의
        - name: 응답 항목 이름 지정
        - description: 응답 항목에 대한 설명 지정
```python
from langchain.output_parsers import ResponseSchema, StructuredOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# 사용자의 질문에 대한 답변
response_schemas = [
    ResponseSchema(name="answer", description="사용자의 질문에 대한 답변"),
    ResponseSchema(
        name="source",
        description="사용자의 질문에 답하기 위해 사용된 `출처`, `웹사이트주소` 이여야 합니다.",
    ),
]

# 응답 스키마를 기반으로 한 구조화된 출력 파서 초기화
output_parser = StructuredOutputParser.from_response_schemas(response_schemas)

# 출력 형식 지시사항을 파싱합니다.
format_instructions = output_parser.get_format_instructions()
prompt = PromptTemplate(
    # 사용자의 질문에 최대한 답변하도록 템플릿을 설정합니다.
    template="answer the users question as best as possible.\n{format_instructions}\n{question}",
    # 입력 변수로 'question'을 사용합니다.
    input_variables=["question"],
    # 부분 변수로 'format_instructions'을 사용합니다.
    partial_variables={"format_instructions": format_instructions},
)

model = ChatOpenAI(temperature=0)  # ChatOpenAI 모델 초기화
chain = prompt | model | output_parser  # 프롬프트, 모델, 출력 파서를 연결
```
<br/>

 - `LLM 요청`
```python
# 대한민국의 수도가 무엇인지 질문합니다.
chain.invoke({"question": "대한민국의 수도는 어디인가요?"})

# 응답
"""
{'answer': '서울', 'source': 'https://ko.wikipedia.org/wiki/%EC%84%9C%EC%9A%B8'}
"""

# 스트리밍 출력
for s in chain.stream({"question": "세종대왕의 업적은 무엇인가요?"}):
    print(s)
```
<br/>

## 4. JsonOutputParser (JSON 형식 출력 파서)

JsonOutputParser는 LLM이 데이터를 조회하고 결과를 도출할 때 답변으로 단순한 문자열이 아니라 지정된 스키마에 맞게 JSON 형식으로 데이터를 반환해 준다.

LLM이 데이터를 정확하고 효율적으로 처리하여 원하는 형태의 JSON을 생성하기 위해서는 모델의 용량이 충분히 커야한다.

 - 용량이 작은 모델에서는 JsonOutputParser를 쓸 때 오류가 발생할 수 있다.

<br/>

### 4-1. 예시

 - `체인 구성`
```python
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.output_parsers import JsonOutputParser
from pydantic import BaseModel, Field
from langchain_openai import ChatOpenAI

# OpenAI 객체를 생성합니다.
model = ChatOpenAI(temperature=0, model_name="gpt-4o")

# 원하는 데이터 구조를 정의합니다.
class Topic(BaseModel):
    description: str = Field(description="주제에 대한 간결한 설명")
    hashtags: str = Field(description="해시태그 형식의 키워드(2개 이상)")

# 질의 작성
question = "지구 온난화의 심각성 대해 알려주세요."

# 파서를 설정하고 프롬프트 템플릿에 지시사항을 주입합니다.
parser = JsonOutputParser(pydantic_object=Topic)


prompt = ChatPromptTemplate.from_messages(
    [
        ("system", "당신은 친절한 AI 어시스턴트 입니다. 질문에 간결하게 답변하세요."),
        ("user", "#Format: {format_instructions}\n\n#Question: {question}"),
    ]
)

prompt = prompt.partial(format_instructions=parser.get_format_instructions())

chain = prompt | model | parser  # 체인을 구성합니다.

chain.invoke({"question": question})  # 체인을 호출하여 쿼리 실행

# 응답
"""
{'description': '지구 온난화는 지구의 평균 기온이 지속적으로 상승하는 현상으로, 이는 주로 인간 활동에 의해 발생하는 온실가스 배출로 인해 발생합니다. 이로 인해 극지방의 빙하가 녹고 해수면이 상승하며, 기후 변화로 인한 자연 재해가 빈번해지고 있습니다.', 'hashtags': '#지구온난화 #기후변화 #온실가스'}
"""
```
<br/>

 - `Pydantic 없이 사용하기`
    - Pydantic 없이도 이 기능을 사용할 수 있습니다.
    - 이 경우 JSON을 반환하도록 요청하지만, 스키마가 어떻게 되어야 하는지에 대한 구체적인 정보는 제공하지 않습니다.
```python
# 질의 작성
question = "지구 온난화에 대해 알려주세요. 온난화에 대한 설명은 `description`에, 관련 키워드는 `hashtags`에 담아주세요."

# JSON 출력 파서 초기화
parser = JsonOutputParser()

# 프롬프트 템플릿을 설정합니다.
prompt = ChatPromptTemplate.from_messages(
    [
        ("system", "당신은 친절한 AI 어시스턴트 입니다. 질문에 간결하게 답변하세요."),
        ("user", "#Format: {format_instructions}\n\n#Question: {question}"),
    ]
)

# 지시사항을 프롬프트에 주입합니다.
prompt = prompt.partial(format_instructions=parser.get_format_instructions())

# 프롬프트, 모델, 파서를 연결하는 체인 생성
chain = prompt | model | parser

# 체인을 호출하여 쿼리 실행
response = chain.invoke({"question": question})

# 출력을 확인합니다.
print(response)

# 응답
"""
{'description': '지구 온난화는 대기 중 온실가스 농도의 증가로 인해 지구의 평균 기온이 상승하는 현상을 말합니다. 이는 기후 변화, 해수면 상승, 극지방 빙하의 감소 등 다양한 환경 문제를 초래합니다.', 'hashtags': ['#지구온난화', '#기후변화', '#온실가스', '#해수면상승', '#환경문제']}
"""
```
<br/>

## 5. PandasDataFrameOutputParser (Pandas 데이터프레임 출력 파서)

Pandas는 파이썬에서 엑셀이나 CSV 데이터를 불러와 정제, 변환, 분석 등 구조화된 데이터를 처리하는 도구이다. Pandas에서는 행과 열로 구성된 2차원 데이터 구조인 데이터프레임으로 데이터를 처리한다.

PandasDataFrameOutputParser는 임의의 Pandas 데이터프레임에서 데이터를 추출하고 이를 형식화된 딕셔너리 형태로 조회하며 연산 결과를 반활 수도 있다.

<br/>

### 5-1. 예시

```python
import pprint
from typing import Any, Dict

import pandas as pd
from langchain.output_parsers import PandasDataFrameOutputParser
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# ChatOpenAI 모델 초기화 (gpt-3.5-turbo 모델 사용을 권장합니다)
model = ChatOpenAI(temperature=0, model_name="gpt-3.5-turbo")

# 출력 목적으로만 사용됩니다.
def format_parser_output(parser_output: Dict[str, Any]) -> None:
    # 파서 출력의 키들을 순회합니다.
    for key in parser_output.keys():
        # 각 키의 값을 딕셔너리로 변환합니다.
        parser_output[key] = parser_output[key].to_dict()
    # 예쁘게 출력합니다.
    return pprint.PrettyPrinter(width=4, compact=True).pprint(parser_output)

# 원하는 Pandas DataFrame을 정의합니다.
# titanic.csv 데이터를 읽어온 뒤 DataFrame 을 로드하여 df 변수에 할당합니다.
# PandasDataFrameOutputParser를 사용하여 DataFrame을 파싱합니다.
df = pd.read_csv("./data/titanic.csv")
df.head()

# 파서를 설정하고 프롬프트 템플릿에 지시사항을 주입합니다.
parser = PandasDataFrameOutputParser(dataframe=df)

# 파서의 지시사항을 출력합니다.
print(parser.get_format_instructions())
"""
The output should be formatted as a string as the operation, followed by a colon, followed by the column or row to be queried on, followed by optional array parameters.
1. The column names are limited to the possible columns below.
2. Arrays must either be a comma-separated list of numbers formatted as [1,3,5], or it must be in range of numbers formatted as [0..4].
3. Remember that arrays are optional and not necessarily required.
4. If the column is not in the possible columns or the operation is not a valid Pandas DataFrame operation, return why it is invalid as a sentence starting with either "Invalid column" or "Invalid operation".

As an example, for the formats:
1. String "column:num_legs" is a well-formatted instance which gets the column num_legs, where num_legs is a possible column.
2. String "row:1" is a well-formatted instance which gets row 1.
3. String "column:num_legs[1,2]" is a well-formatted instance which gets the column num_legs for rows 1 and 2, where num_legs is a possible column.
4. String "row:1[num_legs]" is a well-formatted instance which gets row 1, but for just column num_legs, where num_legs is a possible column.
5. String "mean:num_legs[1..3]" is a well-formatted instance which takes the mean of num_legs from rows 1 to 3, where num_legs is a possible column and mean is a valid Pandas DataFrame operation.
6. String "do_something:num_legs" is a badly-formatted instance, where do_something is not a valid Pandas DataFrame operation.
7. String "mean:invalid_col" is a badly-formatted instance, where invalid_col is not a possible column.

...
"""
```
<br/>

 - `컬럼에 대한 값 조회`
```python
# 열 작업 예시입니다.
df_query = "Age column 을 조회해 주세요."


# 프롬프트 템플릿을 설정합니다.
prompt = PromptTemplate(
    template="Answer the user query.\n{format_instructions}\n{query}\n",
    input_variables=["query"],  # 입력 변수 설정
    partial_variables={
        "format_instructions": parser.get_format_instructions()
    },  # 부분 변수 설정
)

# 체인 생성
chain = prompt | model | parser

# 체인 실행
parser_output = chain.invoke({"query": df_query})

# 출력
format_parser_output(parser_output)
```
<br/>

 - `첫 번째 행 검색`
```python
# 행 조회 예시입니다.
df_query = "Retrieve the first row."

# 체인 실행
parser_output = chain.invoke({"query": df_query})

# 결과 출력
format_parser_output(parser_output)
```
<br/>

 - `특정 열에서 일부 행의 평균 검색`
```python
# row 0 ~ 4의 평균 나이를 구합니다.
df["Age"].head().mean() # 31.2

# 임의의 Pandas DataFrame 작업 예시, 행의 수를 제한합니다.
df_query = "Retrieve the average of the Ages from row 0 to 4."

# 체인 실행
parser_output = chain.invoke({"query": df_query})

# 결과 출력
print(parser_output)
"""
{'mean': 31.2}
"""
```
<br/>

## 6. DatetimeOutputParser (날짜 형식 출력 파서)

DatetimeOutputParser는 LLM의 출력을 datetime 형식으로 파싱하는 데 사용할 수 있다.

<br/>

### 6-1. 예시

 - `출력 파서`
```python
from langchain.output_parsers import DatetimeOutputParser
from langchain.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# 날짜 및 시간 출력 파서
output_parser = DatetimeOutputParser()
output_parser.format = "%Y-%m-%d"

# 사용자 질문에 대한 답변 템플릿
template = """Answer the users question:\n\n#Format Instructions: \n{format_instructions}\n\n#Question: \n{question}\n\n#Answer:"""

prompt = PromptTemplate.from_template(
    template,
    partial_variables={
        "format_instructions": output_parser.get_format_instructions()
    },  # 지침을 템플릿에 적용
)

# 프롬프트 내용을 출력
prompt
"""
PromptTemplate(input_variables=['question'], partial_variables={'format_instructions': "Write a datetime string that matches the following pattern: '%Y-%m-%d'.\n\nExamples: 0751-08-07, 0937-04-06, 0298-07-15\n\nReturn ONLY this string, no other words!"}, template='Answer the users question:\n\n#Format Instructions: \n{format_instructions}\n\n#Question: \n{question}\n\n#Answer:')
"""
```
<br/>

 - `LLM 요청`
```python
# Chain 을 생성합니다.
chain = prompt | ChatOpenAI() | output_parser

# 체인을 호출하여 질문에 대한 답변을 받습니다.
output = chain.invoke({"question": "Google 이 창업한 연도는?"})

# 결과를 문자열로 변환
output.strftime("%Y-%m-%d")

# 응답
"""
'1998-09-04'
"""
```
<br/>

## 7. EnumOutputParser (열거형 출력 파서)

EnumOutputParser는 언어 모델의 출력을 미리 정의된 열거형 값 중 하나로 파싱하는 도구이다. LLM에게 정해진 선택지를 미리 전달하고 그 중에서 하나를 골라서 답변할 수 있게 하므로 출력 데이터의 일관성을 유지하고 예측 가능성을 높일 수 있다.

<br/>

### 7-1. 예시

 - `열거형 클래스 정의 및 열거형 출력 파서 정의`
```python
from langchain.output_parsers.enum import EnumOutputParser
from enum import Enum

class Colors(Enum):
    RED = "빨간색"
    GREEN = "초록색"
    BLUE = "파란색"

# EnumOutputParser 인스턴스 생성
parser = EnumOutputParser(enum=Colors)
```
<br/>

 - `체인 구성`
    - 프롬프트에 사람의 정보({person})와 파싱 지침({instructions})을 포함시킵니다.
    - parser.get_format_instructions() 함수를 호출하여 파싱 지침을 가져옵니다.
    - 프롬프트, ChatOpenAI 모델, 파서를 연결하여 처리 체인을 구성합니다.
```python
from langchain_core.prompts import PromptTemplate
from langchain_openai import ChatOpenAI

# 프롬프트 템플릿을 생성합니다.
prompt = PromptTemplate.from_template(
    """다음의 물체는 어떤 색깔인가요?

Object: {object}

Instructions: {instructions}"""
    # 파서에서 지시사항 형식을 가져와 부분적으로 적용합니다.
).partial(instructions=parser.get_format_instructions())
# 프롬프트와 ChatOpenAI, 파서를 연결합니다.
chain = prompt | ChatOpenAI() | parser
```
</br>

 - `LLM 요청`
```python
response = chain.invoke({"object": "하늘"})  # "하늘" 에 대한 체인 호출 실행
print(response)

# 응답
"""
Colors.BLUE
"""
```
