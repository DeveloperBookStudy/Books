
---

## 프로세스 통신의 역사

### 기존 RPC

RPC란 클라이언트가 로컬 메서드를 호출하는 것처럼 원격으로 메서드의 기능을 호출할 수 있었다. 그 종류에는 CORBA나 자바 RMI 등이 있었는데, 이런 RPC 구현은 상호 운용성을 저해하는 TCP와 같은 통신 프로토콜로 구축되고 과장된 규격에 기반을 두기 때문에 매우 복잡하다.

### SOAP

기존 RPC 구현의 한계로 MS나 IBM과 같은 대규모 기업들은 SOAP라는 통신 기술을 설계해 크게 홍보했다. SOAP는 서비스 지향 아키텍처에서 서비스 간 XML 기반의 구조화된 데이터 교환용 표준 통신 기술이며, HTTP와 같은 프로토콜을 통해 통신한다.

SOAP를 사용하면 서비스 인터페이스, 해당 서비스의 연산과 호출에 사용되는 XML 메시지 포맷을 정의할 수 있었다. SOAP는 규격의 복잡성과 함께 메시지 포맷의 복잡성 때문에 분산 애플리케이션 구축의 민첩성을 저해하며, REST 아키텍처로 대체되게 된다.

### REST

REST는 로이 필딩의 박사 학위 논문에서 시작된 아키텍처 스타일이다. REST는 분산된 애플리케이션을 리소스 모음으로 모델링하는 자원 지향 아키텍처 기반이며, 리소스에 액세스하는 클라이언트가 해당 리소스의 상태를 변경할 수 있다.

REST의 실질적인 구현은 HTTP이며, HTTP에서는 RESTful 웹 애플리케이션을 고유한 식별자로 액세스할 수 있는 리소스 모음으로 모델링한다.

이러한 RESTful 서비스는 최신 마이크로서비스 기반 애플리케이션의 메시징 프로토콜로 사용할 수 없는 몇 가지 주요 제한 사항이 있다.

1. 비효율적 텍스트 기반 메시지 프로토콜

    본질적으로 RESTful 서비스는 HTTP 1.x와 같은 텍스트 기반 전송 프로토콜로 구축되며, JSON처럼 사람이 읽을 수 있는 텍스트 포맷을 활용한다. 서비스 간 통신의 경우 사람이 읽을 수 있는 텍스트 기반 포맷을 사용할 필요가 없기 때문에 JSON과 같은 텍스트 포맷을 사용하는 것은 비효율적이다.

    클라이언트 애플리케이션(출발지)은 서버로 전송할 바이너리 콘텐츠를 만든 후에 해당 바이너리 구조체를 텍스트로 변환한다. 그리고 네트워크를 통해 텍스트로 전송하고 서비스(도착지) 측에서 다시 바이너리 구조로 변환한다. 이 방식보다는 서비스와 소비자의 비즈니스 로직으로 바로 매핑될 수 있는 바이너리 형식으로 쉽게 전송하는 것이 낫다.

2. 엄격한 타입 점검 부족

    폴리글랏 기술(요구 사항이나 시스템 성격에 맞는 다양한 언어를 사용하는 것)으로 구축돼 네트워크를 통해 제공되는 서비스가 점점 증가함에 따라 명확하고 엄격하게 점검되는 서비스 정의가 중요해진다. 기존 RESTful 서비스에서 사용되는 OpenAPI/Swagger와 같은 대부분 서비스 정의 기술은 근간의 아키텍처 스타일이나 메시징 프로토콜에 처음부터 고려되지 않아 이와 잘 통합되지 않는다.

    이는 분산 애플리케이션 구축에 많은 비호환성, 런타임 에러, 상호호환성 문제 등의 문제를 야기한다. 예를 들면 RESTful 서비스를 개발할 때에는 서비스 정의나 애플리케이션 사이에 공유되는 정보의 타입 정의가 따로 요구되지 않는다. 오히려 서비스되는 텍스트 포맷을 확인하거나 OpenAPI와 같은 서드파티 API 정의 기술을 활용한다. 결국 최신의 엄격한 타입 서비스 정의 기술과 폴리글랏용 서버 및 클라이언트 측 중요 코드를 생성하는 프레임워크의 필요성이 증대된다.

3. REST 아키텍처 스타일 강제의 어려움

    RESTful하게 만드는 데 많은 노력이 들어간다는 게 단점이라는데 이해가 되진 않음.

## gRPC의 시작

구글은 스터비라는 범용 RPC 프레임워크를 사용해 여러 데이터센터에 있는 서로 다른 기술로 구축된 수천 개의 마이크로서비스를 연결했고, 이를 바탕으로 개선하여 2015년도에 오픈소스 RPC 프레임워크로 gRPC를 출시한다.

### gRPC의 장점

1. 프로세스 간 통신 효율성

    gRPC는 JSON이나 XML과 같은 텍스트 형식을 사용하는 대신 프로토콜 버퍼 기반 바이너리 프로토콜을 사용해 gRPC 서비스 및 클라이언트와 통신한다. 또한 HTTP/2 위에 프로토콜 버퍼로 구현되기에 프로세스 간 통신 속도가 매우 빨라지며, 가장 효율적인 프로세스 간 통신 기술 중 하나가 된다.

2. 간단 명확한 서비스 인터페이스와 스키마

    gRPC는 애플리케이션 개발용 계약 우선 접근 방식을 권장한다. (서비스 제공을 위한 개발 장식 중 하나로 명세를 먼저 정의하고 개발하는 것을 일컫는다.) 이를 통해 간단하지만 일관되고 안정적인 확장 가능한 애플리케이션 개발 경험을 제공한다.

3. 엄격한 타입 점검 형식

    gRPC 서비스를 정의하고자 프로토콜 버퍼를 사용하기 때문에 gRPC 서비스 계약은 애플리케이션 간 통신에 사용할 데이터 타입을 정확하게 정의한다. 정적 타이핑은 클라우드 네이티브 애플리케이션을 구축할 때 발생 가능한 대부분의 에러를 극복하는 데 도움이 된다.

4. 폴리글랏

    gRPC는 여러 프로그래밍 언어와 작동하도록 설계됐고, 프로토콜 버퍼 기반의 gRPC 서비스 정의는 특정 언어에 구애받지 않는다.

5. 이중 스트리밍

    gRPC는 클라이언트나 서버 측 스트리밍을 기본적으로 지원하며, 서비스 정의 자체에 포함되기 때문에 스트리밍 서비스나 스트리밍 클라이언트를 훨씬 쉽게 개발할 수 있다.

6. 유용한 내장 기능 지원(인증, 암호화, 데드라인과 타임아웃, 메타데이터 교환, 압축, 로드밸런싱 등)

7. 클라우드 네이티브 생태계와 통합

8. 성숙하고 널리 채택됨

### gRPC 단점

1. 외부 서비스 부적합

    애플리케이션 간 통신이 아닌 외부 클라이언트에 제공하려는 경우 대부분 외부 사용자는 gRPC가 새롭기 때문에 적합하지 않을 수 있다. gRPC는 강력한 타입 속성을 갖기 때문에 상대적으로 유연한 GraphQL 등에 비해 사용자는 훨씬 적은 제어권을 갖는다. 이를 개선하기 위해 gRPC 게이트웨이가 설계됐다.

2. 서비스 정의의 급격한 변경에 따른 개발 프로세스 복잡성

    gRPC 서비스 정의가 변경되면 일반적으로 클라이언트와 서버 코드 모두 다시 생성해야 한다. 이는 기존의 지속적인 통합(CI) 프로세스에 통합돼야 하며 전체 개발 수명 주기를 복잡하게 할 수 있다. 하지만 대부분의 서비스 정의 변경은 서비스 계약을 위반하지 않게 수용될 수 있고, gRPC는 주요 변경 사항이 없는 다른 버전의 프로토콜을 사용해 클라이언트 및 서버와 문제없이 상호작용할 수 있다.

3. 상대적으로 작은 생태계

    gRPC 생태계는 여전히 기존 REST나 HTTP 프로토콜에 비해 상대적으로 작다. 브라우저와 모바일 애플리케이션에서 gRPC의 지원도 여전히 초기 단계다.

## gRPC 시작

### 1. 서비스 정의 작성

gRPC 애플리케이션을 개발할 때 가장 먼저 해야 할 일은 소비자가 원격으로 호출할 수 있는 메서드와 메서드의 파라미터, 사용할 메시지 포맷 등을 포함하는 서비스 인터페이스를 정의하는 것이다.

다음 단계는 서비스 정의를 프로토콜 버퍼 정의로 작성하는 것인데, 서비스와 메시지 타입을 정의한다. 서비스는 메서드로 구성되며 각 메서드는 타입, 입력과 출력 파라미터로 정의된다.

1. 메시지 정의

    메시지는 클라이언트와 서비스 간에 교환되는 데이터 구조이다. 예제에서는 Product와 ProductID를 사용한다. Product는 시스템에 새 제품을 추가하거나 특정 제품을 검색할 때 반환되는 제품 정보이며, ProductID는 제품의 고유 식별자이다.

    ```protobuf
    message ProductID {
      string value = 1;
    }
    # 여기서 String은 프로토콜 버퍼 라이브러리에서 제공하는 google.protobuf.StringValue 타입
    ```

    ```protobuf
    message Product {
      string id = 1;
      string name = 2;
      string description = 3;
      float price = 4;
    }
    # 여기서 각 메시지 필드에 지정된 번호는 메시지에서 필드를 고유하게 식별하는 데 사용되기 때문에, 같은 메시지 정의 안에서
