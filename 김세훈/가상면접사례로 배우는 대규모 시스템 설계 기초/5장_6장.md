# 분산 Key-Value 저장소 설계

## 1. Key-Value 저장소란?

키-값(Key-Value) 저장소는 비관계형 데이터베이스(NoSQL)의 한 종류입니다. 이 저장소에 저장되는 모든 값(Value)은 고유한 식별자인 키(Key)를 가집니다. 이러한 키와 값의 연결 관계를 **키-값 쌍(Key-Value Pair)**이라고 부릅니다.

값은 문자열, 리스트, 객체 등 다양한 형태가 될 수 있습니다. 널리 알려진 키-값 저장소로는 **아마존 다이나모(Amazon DynamoDB)**, **멤캐시드(Memcached)**, **레디스(Redis)** 등이 있습니다.

### 1-1. 단일 서버 Key-Value 저장소

한 대의 서버만 사용하는 키-값 저장소의 설계는 비교적 쉽습니다. 가장 직관적인 방법은 키-값 쌍 전체를 메모리의 해시 테이블(Hash Table)에 저장하는 것입니다. 이 접근법은 빠른 속도를 보장하지만, 모든 데이터를 메모리 안에 두는 것이 물리적으로 불가능할 수 있다는 명확한 한계를 가집니다.

### 1-2. 분산 Key-Value 저장소와 CAP 정리

이러한 한계를 극복하기 위해 키-값 쌍을 여러 서버에 분산시키는 **분산 키-값 저장소(분산 해시 테이블)**를 사용합니다. 분산 시스템을 설계할 때는 **CAP 정리(CAP Theorem)**를 반드시 이해하고 있어야 합니다.

> CAP 정리란?
분산 컴퓨팅 환경에서 데이터 일관성(Consistency), 가용성(Availability), **파티션 감내(Partition Tolerance)**라는 세 가지 요구사항을 동시에 모두 만족하는 시스템을 설계하는 것은 불가능하다는 정리입니다.
> 
- **데이터 일관성 (Consistency)**: 분산 시스템에 접속하는 모든 클라이언트는 어떤 노드에 접속했는지에 관계없이 언제나 같은 데이터를 보게 되어야 합니다.
- **가용성 (Availability)**: 분산 시스템의 일부 노드에 장애가 발생하더라도, 클라이언트는 항상 정상적으로 응답을 받을 수 있어야 합니다.
- **파티션 감내 (Partition Tolerance)**: '파티션'은 노드 간 통신 장애가 발생한 상황을 의미합니다. 파티션 감내는 네트워크에 파티션이 생기더라도 시스템은 계속 동작해야 한다는 것을 뜻합니다.

**[CAP 트레이드오프]**
현실 세계의 분산 시스템에서 네트워크 장애는 피할 수 없는 문제로 간주하므로, 파티션 감내(P)는 반드시 보장되어야 합니다. 따라서 시스템 설계자는 일관성(C)과 가용성(A) 사이에서 하나를 선택해야 합니다.

- **CP 시스템 (일관성 > 가용성):** 데이터 불일치를 피하기 위해, 파티션 발생 시 영향을 받는 데이터의 쓰기/읽기 연산을 중단합니다. 이로 인해 일관성은 지켜지지만 가용성이 희생됩니다. 은행 시스템 등이 이 모델을 따릅니다.
- **AP 시스템 (가용성 > 일관성):** 파티션이 발생하더라도 시스템은 항상 응답해야 합니다. 낡은 데이터를 반환할 위험이 있더라도 읽기/쓰기 연산을 허용하며, 추후 파티션 문제가 해결될 때 데이터를 동기화합니다.

## 2. 분산 시스템의 핵심 설계 요소

이러한 분산 환경의 문제들을 해결하기 위해 다음과 같은 핵심 컴포넌트들이 필요합니다.

- 데이터 파티셔닝
- 데이터 다중화
- 데이터 일관성 유지
- 비일관성 해소
- 장애 처리

### 2-1. 데이터 파티셔닝: 안정 해시 (Consistent Hashing)

대규모 데이터를 여러 서버에 효과적으로 분산시키기 위한 기술입니다. 데이터를 파티션 단위로 나눌 때는 다음 두 가지를 중요하게 고려해야 합니다.

1. 데이터를 여러 서버에 고르게 분산시킬 수 있는가?
2. 노드가 추가되거나 삭제될 때 데이터의 이동을 최소화할 수 있는가?

이에 대한 가장 효과적인 해결책이 바로 **안정 해시**입니다.

### 가. 기존 방식의 문제점: 해시 키 재배치

N개의 캐시 서버가 있을 때, `serverIndex = hash(key) % N` 공식을 사용하는 것이 일반적입니다. 이 방법은 서버 풀의 크기가 고정되어 있을 때는 잘 동작하지만, 서버가 추가되거나 삭제되어 **N값이 변하면 대부분의 키가 재배치되는 문제**가 발생합니다.

### 나. 안정 해시의 동작 원리

안정 해시는 해시 테이블 크기가 조정될 때 재배치되는 키의 수를 평균적으로 k/n개(k: 키 개수, n: 슬롯 개수)로 최소화하는 기술입니다.

1. **해시 링(Hash Ring) 구성**: SHA-1 같은 해시 함수를 사용하여 서버의 IP나 이름을 해시 값으로 변환한 뒤, 이를 가상의 원형 링(Ring) 위 특정 위치에 배치합니다.
2. **키 배치**: 저장할 데이터의 키(Key) 또한 동일한 해시 함수로 해싱하여 링 위의 한 위치에 배치합니다.
3. **서버 탐색**: 어떤 키가 저장될 서버는, 해당 키의 위치에서부터 **시계 방향으로 링을 탐색해 나가면서 만나는 첫 번째 서버**입니다.

이러한 원리 덕분에 서버가 추가되거나 삭제되더라도, 영향을 받는 인접한 일부 키들만 재배치하면 되므로 전체 시스템의 부하를 최소화할 수 있습니다.

### 다. 문제점과 해결책: 가상 노드 (Virtual Node)

기본적인 안정 해시 알고리즘은 두 가지 문제가 있습니다.

1. **파티션의 불균형**: 서버가 링 위에 무작위로 배치되므로, 어떤 서버는 매우 큰 해시 공간을, 다른 서버는 매우 작은 공간을 할당받을 수 있습니다.
2. **키의 분포 불균형**: 키들이 링 위에 균등하게 분포한다는 보장이 없어 특정 서버에만 데이터가 몰리는 **핫스팟(Hot Spot)** 현상이 발생할 수 있습니다.

이 문제를 해결하기 위해 **가상 노드(Virtual Node)** 또는 복제(Replica) 기법이 제안되었습니다. 가상 노드는 실제 노드를 가리키는 가상의 노드로, 하나의 물리 서버가 링 위에 여러 개의 가상 노드를 가집니다. 노드의 개수를 늘리면 표준 편차가 작아져 데이터가 훨씬 더 균등하게 분포됩니다.

### 라. 안정 해시의 이점 및 사용 사례

- 서버 추가/삭제 시 재배치되는 키의 수를 최소화합니다.
- 데이터를 균등하게 분포시켜 수평적 규모 확장성을 용이하게 합니다.
- 핫스팟 키 문제를 완화하여 서버 과부하 가능성을 줄입니다.
- **사용 사례**: 아마존 다이나모DB, 아파치 카산드라, 디스코드 등

### 2-2. 데이터 다중화 (Data Replication)

높은 가용성과 안정성을 확보하기 위해, 데이터를 **N개의 서버에 비동기적으로 다중화(복제)**할 필요가 있습니다. 여기서 N은 시스템 요구사항에 따라 조정 가능한 값입니다.

데이터 사본을 보관할 N개의 서버는, 안정 해시 링 위에서 특정 키의 위치로부터 시계 방향으로 순회하며 만나는 첫 N개의 서버로 선정하는 방식을 사용합니다.

### 2-3. 데이터 일관성 (Data Consistency)

여러 노드에 다중화된 데이터는 적절히 동기화되어야 합니다. 이때 **정족수 합의(Quorum Consensus) 프로토콜**을 사용하여 읽기/쓰기 연산의 일관성을 보장할 수 있습니다.

- **N**: 사본 개수
- **W (쓰기 정족수)**: 쓰기 연산이 성공으로 간주되기 위해 응답을 받아야 하는 최소 서버 수
- **R (읽기 정족수)**: 읽기 연산이 성공으로 간주되기 위해 응답을 받아야 하는 최소 서버 수

**[W, R, N 값의 구성]**

- `R=1, W=N`: 빠른 읽기 연산에 최적화된 시스템
- `W=1, R=N`: 빠른 쓰기 연산에 최적화된 시스템
- `W + R > N`: **강한 일관성(Strong Consistency)** 보장 (읽기 정족수와 쓰기 정족수가 반드시 겹침)
- `W + R <= N`: 강한 일관성을 보장하지 않음

**[일관성 모델]**

- **강한 일관성 (Strong Consistency)**: 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환합니다. 클라이언트는 절대 낡은 데이터를 보지 못합니다.
- **결과적 일관성 (Eventual Consistency)**: 약한 일관성의 한 형태로, 쓰기 연산의 결과가 당장은 아니더라도 **결국에는** 모든 사본에 반영(동기화)되는 것을 보장하는 모델입니다.

### 2-4. 비일관성 해소: 데이터 버저닝

데이터를 다중화하면 가용성은 높아지지만, 사본 간의 일관성이 깨질 가능성도 커집니다. **버저닝(Versioning)**은 이 문제를 해결하기 위한 기술로, 데이터가 변경될 때마다 덮어쓰는 대신 새로운 버전을 만드는 것을 의미합니다. 각 버전의 데이터는 변경 불가능(Immutable)하므로, 충돌이 발생했을 때 어떤 버전이 최신인지 판단하고 병합하는 근거가 됩니다. (벡터 시계(Vector Clock)가 이를 구현하는 대표적인 기술입니다.)

- 설명
    
    **버저닝의 핵심 아이디어는 간단합니다: "절대 데이터를 덮어쓰지 말고, 변경될 때마다 새로운 버전의 기록을 남기자."**
    
    마치 구글 문서의 '버전 기록' 기능과 같습니다.
    
    - **변경 전:** 데이터: "포도"
    - **A가 변경:** 데이터: "포도" (버전 1) -> 데이터: "사과" (버전 2)
    - **B가 변경:** 데이터: "포도" (버전 1) -> 데이터: "바나나" (버전 2)
    
    이렇게 하면 나중에 "사과(버전 2)"와 "바나나(버전 2)"라는 두 개의 버전이 충돌했다는 사실을 명확히 알 수 있습니다. 데이터를 덮어썼다면 이런 사실조차 알 수 없었을 겁니다.
    
    **버저닝의 장점:**
    
    - 데이터 변경 이력을 모두 추적할 수 있습니다.
    - 데이터 충돌이 발생했음을 감지할 수 있습니다.
    
    하지만 이것만으로는 "사과"와 "바나나" 중 **어느 것이 더 나중에 일어난 일인지, 아니면 동시에 일어난 일인지**를 알 수 없습니다. 이걸 해결해 주는 것이 바로 벡터 시계입니다.
    
    ---
    
    ### 2. 벡터 시계 (Vector Clock): "너 몇 번째 수정이야?" 서로 물어보는 똑똑한 시계
    
    **벡터 시계는 각 서버가 자신만의 '수정 횟수 카운터'를 가지고, 다른 서버와 통신할 때마다 이 카운터 정보를 교환하는 기술입니다.**
    
    서버 A, B, C가 있다고 상상해 보세요. 각 데이터에는 이런 시계가 붙어 있습니다.
    
    [A서버의 카운터, B서버의 카운터, C서버의 카운터]
    
    **시나리오:**
    
    1. **초기 상태:** 데이터 X의 벡터 시계는 모든 서버에서 [A:0, B:0, C:0] 입니다.
    2. **사용자 1이 서버 A에서 데이터 X를 수정합니다.**
        - 서버 A는 자신의 카운터를 1 올립니다.
        - 데이터 X의 새 버전과 함께 벡터 시계 [A:1, B:0, C:0] 를 저장합니다.
    3. **사용자 2가 서버 B에서 데이터 X를 수정합니다.**
        - 서버 B는 자신의 카운터를 1 올립니다.
        - 데이터 X의 새 버전과 함께 벡터 시계 [A:0, B:1, C:0] 를 저장합니다.
    4. **나중에 서버 A가 서버 C에게 자신의 데이터를 보냅니다.**
        - 서버 C는 데이터를 받고, 벡터 시계 [A:1, B:0, C:0] 를 확인합니다.
        - 자신의 카운터(C:0)를 1 올리고, 두 시계를 비교해서 최신 값으로 합칩니다.
        - 서버 C의 최종 벡터 시계는 [A:1, B:0, C:1] 이 됩니다.
    
    ---
    
    ### 그래서 벡터 시계로 무엇을 알 수 있는가? (핵심)
    
    나중에 충돌하는 두 데이터의 벡터 시계를 비교하면 관계를 알 수 있습니다.
    
    - 데이터 1: [A:2, B:1, C:0]
    - 데이터 2: [A:1, B:3, C:0]
    
    ### **비교 규칙:**
    
    1. **A가 B보다 최신인가?** -> A의 모든 카운터가 B의 모든 카운터보다 크거나 같으면 "최신이다(후손이다)".
    2. **위 규칙에 해당하지 않으면?** -> "서로 관계없이 동시에 수정되었다(충돌했다)".
    
    ### **위 예시 분석:**
    
    - A의 카운터 2는 B의 카운터 1보다 큽니다.
    - 하지만 A의 카운터 1은 B의 카운터 3보다 작습니다.
    - **결론: 둘은 서로의 변경 사항을 모른 채 동시에 수정되었습니다. 즉, 충돌이 발생했습니다!**
    
    이제 시스템은 이 충돌을 감지하고, "사용자님, '사과'와 '바나나' 데이터가 충돌했는데 어느 것을 선택하시겠어요?" 라고 물어보거나, 정해진 규칙에 따라 자동으로 병합할 수 있습니다.
    
    ### 요약
    
    - **데이터 버저닝:** "덮어쓰지 마!" 데이터의 변경 이력을 모두 남겨서 충돌을 감지할 수 있게 함.
    - **벡터 시계:** "너 몇 번째야?" 서버끼리 수정 횟수 정보를 교환하여, 데이터 간의 선후 관계(누가 최신인지) 또는 동시 발생(충돌인지)을 논리적으로 판단하게 해주는 똑똑한 시계.

### 2-5. 장애감지

분산시스템에서는 한 대 서버가 죽었다는 신호를 보내도 바로 해당 서버를 장애처리 하지는 않는다. 보통 두 대 이상의 서버가 똑같이 서버 A의 장애를 보고해야 해당 서버에 실제로 장애가 발생했다고 간주하게 된다.

모든 노드 사이에 멀티캐스팅 채널을 구축하는 것이 서버 장애를 감지하는 가장 손쉬운 방법이다. 하지만 이런 방법은 서버 갯수가 많아지면 비효율적이기 때문에, 가십 프로토콜 같은 분산형 장애 감지 솔루션을 채택하는 편이 효율적이다.

가십 프로토콜의 동작 원리는 다음과 같다.

- 각 노드는 멤버십 목록을 유지한다. 멤버십 목록은 각 멤버 ID와 하트비트 카운터 쌍의 목록이다.
- 각 노드는 주기적으로 자신의 박동 카운터를 증가시킨다.
- 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보낸다.
- 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신 값으로 갱신한다.
- 어떤 멤버의 박동 카운터 값이 지정된 시간 동안 갱신되지 않으면 해당 멤버는 장애상태인 것으로 간주한다.

### 장애 감지 후 가용성 확보: 단서 후 임시 위탁 (Hinted Handoff)

가십 프로토콜(Gossip Protocol) 등을 통해 특정 서버의 장애가 감지되면, 시스템은 데이터의 일관성과 가용성 사이에서 중요한 결정을 내려야 합니다.

- **엄격한 정족수(Strict Quorum) 접근법:**
    - 데이터 일관성(Consistency)을 최우선으로 합니다.
    - 장애가 발생하여 정족수(W 또는 R)를 만족시킬 수 없게 되면, 해당 데이터에 대한 읽기와 쓰기 연산을 모두 금지합니다.
    - 이로 인해 시스템의 가용성(Availability)은 떨어집니다.
- **느슨한 정족수(Loose Quorum) 접근법과 단서 후 임시 위탁:**
    - 가용성(Availability)을 최우선으로 합니다.
    - 정족수 요구사항을 일시적으로 완화하여, 장애 상황에서도 서비스가 계속 동작하도록 합니다.

이러한 느슨한 접근법을 구현하는 대표적인 기술이 **단서 후 임시 위탁(Hinted Handoff)**입니다.

### **단서 후 임시 위탁(Hinted Handoff)의 동작 원리**

1. **건강한 서버 선택:** 쓰기 연산(W)이나 읽기 연산(R)을 수행할 때, 안정 해시 링에서 **현재 접속 가능한 건강한 서버** 중에서 정족수만큼 서버를 선택합니다.
2. **임시 위탁 (Handoff):** 만약 원래 데이터를 담당해야 할 서버 A가 장애 상태라면, 요청을 받은 서버는 그 쓰기 연산을 **임시로 다른 건강한 서버 B에게 위탁하여 처리**합니다.
3. **단서(Hint) 남기기:** 이때, 임시로 작업을 처리한 서버 B는 **"이 데이터는 원래 서버 A의 것이었음"**이라는 **단서(Hint)를 별도로 저장**해 둡니다. 이 단서는 임시 데이터가 누구의 것인지를 알려주는 메타데이터입니다.
4. **복구 및 일괄 반영:** 나중에 원래 담당 서버였던 A가 복구되면, 단서를 가지고 있던 서버 B는 A의 복구를 감지하고, 그동안 임시로 처리했던 모든 변경 사항을 A에게 **일괄적으로 전송하여 데이터 일관성을 맞춥니다.**

이 기법을 통해, 시스템은 일부 서버에 장애가 발생하더라도 쓰기/읽기 연산을 멈추지 않고 계속 처리하여 높은 가용성을 유지할 수 있으며, 동시에 장애가 복구된 후에는 데이터 일관성을 최종적으로 보장할 수 있습니다.

반면에 영구 장애 상태의 처리는 반-엔트로피 프로토콜을 구현하는 방법이 있다. 반 엔트로피 프로토콜은 사본들을 비교하여 최신 버전으로 갱신하는 과정을 포함한다

- 설명
    
    **반 엔트로피 프로토콜**은 분산 시스템에서 서버들 간의 **데이터 불일치(엔트로피)를 줄이고, 최종적으로 데이터를 일치시키는** 주기적인 동기화 방법입니다.
    
    핵심 동작은 매우 간단합니다.
    
    1. **주기적인 비교:** 두 서버가 주기적으로 서로를 무작위로 선택합니다.
    2. **차이점 발견:** 자신들이 가진 데이터(또는 데이터의 요약본/체크섬)를 비교하여 차이점을 찾아냅니다.
    3. **최신 데이터로 동기화:** 차이점을 발견하면, 오래된 데이터를 가진 서버가 최신 데이터를 가진 서버로부터 데이터를 복사하여 자신의 데이터를 업데이트합니다
